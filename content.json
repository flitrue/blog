[{"title":"关于 Vue Mixin 和 Directive 的使用","date":"2017-01-31T01:35:00.000Z","path":"2017/01/31/vue/vue_mixins_directive/","text":"使用 vue 组件化开发已经很长时间，组件化的意义就是把在多个页面中共有的逻辑（显示/功能）封装，在多个页面或者多个项目中重复使用以提高开发效率。 但组件中共有的逻辑如何重用呢？例如： 我们再开发一个 popover 组件时都会有如下功能： 点击外部时关闭弹出 滚动条滚动或者窗口大小发生改变时重新定位 这里我们需要监听三个事件，一个是外部被点击事件，滚动条滚动，窗口大小发生改变，这些功能都很可能在别的组件中被使用，我们要将这些共有功能封装起来。 Vue 中提供了 mixin（混合） 和 directive 两种方式用于封装多个组件内的共有功能。 Mixin（混合） 混合是一种灵活的分布式复用 Vue 组件的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。 当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用 ： 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。 popover 监听滚动和window大小变化功能，可以使用 mixin 完成 12345678910111213141516171819202122232425262728293031323334353637// scroll.jsexport default &#123; props: &#123; scroller: &#123; type: [HTMLDocument, Element, Window], default () &#123; return window &#125; &#125; &#125;, mounted () &#123; this.$bindScroll() &#125;, methods: &#123; $bindScroll () &#123; if (!this.scroller) return this._handleScroll = (e) =&gt; &#123; if (this.onScroll) this.onScroll() &#125; this.scroller.addEventListener('scroll', this._handleScroll) &#125;, $unbindScroll (scroller) &#123; scroller = scroller || this.scroller if (this._handleScroll) scroller.removeEventListener('scroll', this._handleScroll) &#125; &#125;, beforeDestroy () &#123; this.$unbindScroll() &#125;, watch: &#123; scroller (scroller, oldScroller) &#123; if (scroller === oldScroller) return this.$unbindScroll(oldScroller) this.$bindScroll(scroller) &#125; &#125;&#125; 1234567891011121314151617181920// resize.jsexport default &#123; mounted () &#123; this.$bindResize() &#125;, methods: &#123; $bindResize () &#123; this._handleResize = (e) =&gt; &#123; if (this.onResize) this.onResize() &#125; window.addEventListener('resize', this._handleResize) &#125;, $unBindResize () &#123; if (this._handleResize) window.removeEventListener('resize', this._handleResize) &#125; &#125;, beforeDestroy () &#123; this.$unBindResize() &#125;&#125; 使用时，引入实现对应的方法即可 123456789101112131415// popover.jsimport Scroll from 'scroll'import Resize from 'resize'export default &#123; mixins: [Scroll, Resize], methods: &#123; onScroll () &#123; // 滚动时处理 &#125;, onResize () &#123; // 窗口大小变化时处理 &#125; &#125;&#125; 同样 scroll 和 resize 也可以再其它组件中使用，复杂的项目中可以使用 mixin 将组件内共有的功能封装，但是要注意保证每个 mixin 处理的功能尽量单一，方便组件内部根据需要集成相应的功能。 Directive（指令） 在 Vue2.0 里面，代码复用的主要形式和抽象是组件——然而，有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。 例如: 需要让输入框根据参数自动 focus 和 blur 123456789// focus.jsexport default &#123; bind (el, binding) &#123; if (binding.value) el.focus() &#125;, update (el, binding) &#123; if (!binding.oldValue &amp;&amp; binding.value) el.focus() &#125;&#125; 12345678910111213141516&lt;template&gt; &lt;input v-focus=\"isFocus\"/&gt;&lt;/template&gt;&lt;script&gt;import focus from 'focus'export default &#123; data () &#123; return &#123; isFocus: false &#125; &#125;, directives: &#123; focus &#125;&#125;&lt;/script&gt; 指令中有很多钩子函数，可以根据实际情况实现 bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update : 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 每个钩子函数都会有如下参数： el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 一般在需要 DOM 操作时我们都需要使用自定义指令的方式去实现，当然一些特殊的事件监听也可以使用指令，例如上述中的监听外部点击事件： 1234567891011121314151617181920212223242526272829303132333435/** * element https://github.com/ElemeFE/element * clickoutside.js */const clickoutsideContext = '@@clickoutsideContext'export default &#123; bind (el, binding, vnode) &#123; const documentHandler = function (e) &#123; if (!vnode.context || el.contains(e.target)) return if (binding.expression) &#123; vnode.context[el[clickoutsideContext].methodName](e) &#125; else &#123; el[clickoutsideContext].bindingFn(e) &#125; &#125; el[clickoutsideContext] = &#123; documentHandler, methodName: binding.expression, bindingFn: binding.value &#125; setTimeout(() =&gt; &#123; document.addEventListener('click', documentHandler) &#125;, 0) &#125;, update (el, binding) &#123; el[clickoutsideContext].methodName = binding.expression el[clickoutsideContext].bindingFn = binding.value &#125;, unbind (el) &#123; document.removeEventListener('click', el[clickoutsideContext].documentHandler) &#125;&#125; 12345678910111213141516&lt;template&gt;&lt;div v-clickoutside=\"handleClickOutSide\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import clickoutside from 'clickoutside'export default &#123; methods: &#123; handleClickOutSide () &#123; // 当外部被点击时调用 &#125; &#125;, directives: &#123; clickoutside &#125;&#125;&lt;/script&gt; 虽然 directive 和 mixin 都可用于封装组件中的公共功能，但是 directive 更趋向于有dom操作时使用，而mixin可以承担更复杂的功能封装。 以上代码，都在 muse-ui 中实践 参考Vue 混合Vue 自定义指令","tags":[{"name":"vue","slug":"vue","permalink":"http://myronliu.com/tags/vue/"}]},{"title":"不断折腾的2016 | 掘金技术征文","date":"2016-12-29T01:00:00.000Z","path":"2016/12/29/随笔/2016/","text":"又到了为抢票发愁的时候，好在今天我终于买到，可以好好的写个2016的总结啦！ 2016从年初到年尾都在不断的折腾，一些新的技术、工具。。。 最后终于从一个半前端成长为一个还算合格的前端攻城狮。 Hexo 搭建自己的博客年初决定今年一定要坚持写博客，从毕业以来尝试了很多的博客平台，包括 csdn，farbox等等，后来决定自己搭建一个博客。开始使用最新版的 wordpress 折腾了一段时间未果，公司有位大牛跟我说github是有pages服务可以搭建静态站点，几番探寻之后决定使用, hexo来搭建一个自己博客，搭建好之后我把搭建过程记录下来，作为新博客的第一篇文章: hexo+coding搭建自己的博客 。 作为一个颜控，找了好多主题之后最终选定 yilia ,买了个 MWeb 编辑器，从年初到现在写了30多篇博客，写作确实是意见令人愉悦的事情，希望明年能也能坚持下来。 ReactNative 开发尝试7月中旬，公司需要做一个阅读类的app，决定使用 react-native 开发安卓端，这个项目的开发时间只有一个人月，但是对我的帮助特别大，当时的技术选型时使用 redux + react-native 开发。 由于是第一次正式开发react-native 项目，于是我选择了noder-react-native 作为参考项目，仔细阅读过代码后，无论是路由、缓存的处理，还是组件抽象，状态的管理都是我耳目一新。这个项目也使用了它的模式进行开发顺利开发完成，自己对组件，状态管理也有了更深的理解。 react-native 开发中也遇到了许多的问题，APP启动的老是会有一段时间的白屏，花了很久时间想在启动的时候给App 设置一张启动图，找了各种插件，最后在android开发同学帮助下解决了这个问题(其实就是设置个背景图的就好了), react-native 版本迭代有点快，有些插件都不能支持现在的版本，所以有些地方需要自己去改动，这段时间经常跟android开发同学沟通，问一些api上的问题，也将一些插件升级之后的问题修复。 最后就是一些集成一些热更新（pushy）,消息推送（jpush）这类的插件, 这次开发收益良多，最终把一些开发过程记录了下来。react-native 开始走向mobile开发 , react-native 给android端设置启动图 和 Vue 的那些事15年底的时候疯狂痴迷 Web Components ，某天看到一个叫 Vue 的框架支持单文件组件, 于是便是一见钟情，疯狂研究vue，刷了vue 教程和api两周之后决定做一些事情。 angular 迁移到 Vue公司 app 中嵌入一些HTML5页面使用的angular 1.x，学完vue之后决定重构，angular迁移到vue 大部分没有什么问题，只是有些地方需要特别注意。 scope 服务使用this， 可以在某些处理函数顶部加上 var scope = this 所有ng的指令对应换成 v-， 事件处理的地方 ng- 换成 @, ng-repeat 替换为 v-for 干掉所有 services ,换成正常的 function vue1.0跟angular还比较接近，迁移起来也比较顺手。 开发Vue组件库使用过vue之后愈发的喜欢，我是一个特别喜欢造轮子的人，老是想写个组件库，一直都很喜欢 material 风格的UI, 在8月初的时候遍开始写自己的第一个UI库，vue-carbon, 这里面大部分的UI是参考 framework7, 写之前把它的代码来来回回撸了好几遍，也是从那时开始flexbox布局使用的越来越熟练，对于vue的组件也有了些自己理解，其中最得意的部分是关于弹出框控制，参考了 vue-popup 的实现方式，也加入了自己思考，最终应用到组件中，一直到后来的 muse-ui 仍然在沿用, 关于 vue 弹窗组件的一些感想 。 后来的时间里，除了对 vue-carbon 的维护，我开始认真的去看 Material Design 的文档，发现之前有很多地方都是不太符合设计规范的，正好的这个时候 vue 2.0 也将要发布，于是便开始计划基于vue2.0 material design 组件，首先我把 material-ui 的源码看了很多遍，因为它是目前为止material最好的实现。三个月的时间里，晚上或是周末的时间基本都在家coding，国庆回家的时候高铁上台太过无聊，于是打开电脑开始coding…. 终于在 11 中旬发布了 Muse UI 的第一个版本，中间也写过一篇博客记录组件的开发 vue 开发波纹点击特效组件 。 Muse UI 发布之后获得了许多人的关注，所以特别感谢支持它的每一位开发者，后来的维护工作比开发复杂的多，好多的组件都反复修改，弹层框相关的组件我都完整重构过，感谢开源社区的强大，也收到很多开发者的 pr 和 issues，后面英文文档翻译都是 LinGuang 、 Justin Toh 帮我完成的。 零零碎碎的一些2016 还有好多的事情： 编辑器最终选择了 Atom: atom这个IDE有点酷 赶了波潮流，玩了下微信小程序: 微信小程序开发初体验 参加过一次 html5 的培训： html5网络连接 html5设备api html5离线存储 html5 语义化 基本用使用 ES6 进行开发了： ES6的二三事(一)/) ES6的二三事(二)-模块化%EF%BC%8D%E6%A8%A1%E5%9D%97%E5%8C%96/) 终于能够熟练使用 webpack、rollup、eslint、karama 这些工具了： node 和 npm 版本升级 npm 发布一个自己的包 使用 rollup 打包你的 ES6 代码 javascript单元测试实践 editorconfig和Eslint规范代码编辑 读过几本书 有过一次说走就走的旅行——厦门 End好久没写博客，年终总结居然花了两天才写完，希望在2017年，自己能够坚持阅读、运动、写博客。。。希望 Vue 越来越好，希望可以在公司顺利推行 Vue2.0，我也会将Muse UI 打磨的越来越完善。 最后，希望世界和平 ！！！ 掘金年度征文 | 2016 与我的技术之路","tags":[{"name":"随笔","slug":"随笔","permalink":"http://myronliu.com/tags/随笔/"}]},{"title":"Muse UI — Vue2.0 和 Material Design 结合","date":"2016-11-12T00:34:00.000Z","path":"2016/11/12/vue/muse_ui/","text":"Vue 2.0 发布以来，很多 vue 的开源项目都开始了升级计划，我也思考着 vue-carbon 的升级之路，9月开工，11月完工， Muse UI 闪亮登场。 先睹为快Muse UI 主要用于移动端和一些对浏览器兼容性要求不高的桌面端应用，先上地址: https://github.com/museui/muse-ui 官网和文档在这： https://museui.github.io/ 特性 基于 vue2.0 开发 组件丰富 丰富的主题，支持自定义主题 可以很好的配合 vue 的其它插件vue-router , vue-validator 使用 友好的 API 使用1npm install muse-ui --save 完整引入1234import Vue from 'vue'import MuseUI from 'muse-ui'import 'muse-ui/dist/muse-ui.css'Vue.use(MuseUI) 按需引入首先需要需要修改 webpack 的配置 1234567891011121314151617&#123; // ... module: &#123; loaders: [ &#123; test: /muse-ui.src.*?js$/, loader: 'babel' &#125; ] &#125;, resolve: &#123; // ... alias: &#123; 'muse-components': 'muse-ui/src' &#125; &#125;&#125; main.js 1234567891011121314import Vue from 'vue'import 'muse-components/style/base.less' // 全局样式包含 normalize.cssimport appbar from 'muse-components/appbar'import avatar from 'muse-components/avatar'import &#123;bottomNav, bottomNavItem&#125; from 'muse-components/bottomNav'import &#123;retina&#125; from 'muse-components/utils'retina() // 1px 处理方案// ...Vue.component(appbar.name, appbar)Vue.component(avatar.name, avatar)Vue.component(bottomNav.name, bottomNav)Vue.component(bottomNavItem.name, bottomNavItem) 示例 bottomNav 的使用12345678910111213141516171819202122&lt;template&gt; &lt;mu-bottom-nav :value=\"bottomNav\" shift @change=\"handleChange\"&gt; &lt;mu-bottom-nav-item value=\"movies\" title=\"Movies\" icon=\"ondemand_video\"/&gt; &lt;mu-bottom-nav-item value=\"music\" title=\"Music\" icon=\"music_note\"/&gt; &lt;mu-bottom-nav-item value=\"books\" title=\"Books\" icon=\"books\"/&gt; &lt;mu-bottom-nav-item value=\"pictures\" title=\"Pictures\" icon=\"photo\"/&gt;&lt;/mu-bottom-nav&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; bottomNav: 'movies' &#125; &#125;, methods: &#123; handleChange (val) &#123; this.bottomNav = val &#125; &#125;&#125;&lt;/script&gt; 关于 Muse为了配合Vue 2.0 改变了 vue-carbon 许多的 API，新增了许多的组件，由于改变的太多，于是更名为 Muse UI，做为一个全新的 UI 框架。 Muse 取自于古希腊神话中的女神，掌管科学与艺术。我希望 Muse 和 Vue 一样能将科学与艺术完美的结合。 后续的工作为了跟随 Vue 2.0, Muse 以 2.0 版本为基础，现在是 alpha 版，后续会不断完善。 修复现有的问题和合理化API 增加单元测试 增加更多快捷操作的api (简单的消息提示，alert, confirm 等等) 增加其它的功能性组件（Notification, Pagination 等等） 开发 weex 版的 muse","tags":[{"name":"vue","slug":"vue","permalink":"http://myronliu.com/tags/vue/"}]},{"title":"微信小程序开发初体验","date":"2016-09-26T00:05:00.000Z","path":"2016/09/26/wechat/wechat_start/","text":"上周被 小程序 刷了屏，吓得我周末赶紧撸了个 小程序 版的 知乎日报 压压惊, 总结一下这个开发体验，和踩过的坑。 先上图 开发环境准备小程序 出来第二天就被破解，第三天微信就把开发工具开发下载了， 现在只需要下载 微信开发者工具 就可以使用了， 创建项目的时候，要选择无 appid, 这样就不会有 appid 的验证了。 目录结构 app.js 注册app逻辑， app.wxss 全局样式文件 app.json 配置信息 pages 存放页面文件 utils 工具类代码 images 图片资源文件 小程序中每一个页面都会有三个文件 .wxml .wxss .js ，对应着结构、样式、和逻辑，相当于网页中的 html css 和 js 的关系。 开发第一个页面代码来自新建项目 12345678910&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;&#125;.userinfo-nickname &#123; color: #aaa;&#125;.usermotto &#123; margin-top: 200px;&#125; 1234567891011121314151617181920212223242526//index.js//获取应用实例var app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125; &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, onLoad: function () &#123; console.log('onLoad') var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125;) &#125;&#125;) 新建的项目中，index 下都会看到这些代码，接下来分别介绍 wxml wxss js wxml这个是页面结构的描述文件, 主要用于以下内容 用标签形式指定组件使用 &lt;view&gt;&lt;/view&gt; 使用 wx:for wx:if 等指令完成一些模板上的逻辑处理 使用 bind* 绑定事件 wxss样式文件，和 css 语法基本一致，不过支持的选择器语法有限 看这里， 可以使用 flexbox 完成布局。内部也可以使用 import 命令引入外部样式文件 12345@import \"common.wxss\";.pd &#123; padding-left: 5px;&#125; js页面逻辑控制， 遵循 commonJs 规范 123456789101112// util.jsfunction formatTime(date) &#123; // ....&#125;function formatDate(date, split) &#123; // ...&#125;module.exports = &#123; formatTime: formatTime, formatDate: formatDate&#125; 1var utils = require(&apos;../../utils/util.js&apos;) 这里的js 并不是在 浏览器环境下运行， 所以 window.* 这一类的代码都会报错， dom 操作也是不被允许的，官方目前好像是不能支持其他的 js 库运行，全封闭式，这个以后应该会逐渐完善。 页面上使用 Page 方法来注册一个页面 1234567891011121314151617181920Page(&#123; data:&#123; // text:\"这是一个页面\" &#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, onReady:function()&#123; // 页面渲染完成 &#125;, onShow:function()&#123; // 页面显示 &#125;, onHide:function()&#123; // 页面隐藏 &#125;, onUnload:function()&#123; // 页面关闭 &#125;&#125;) 当我们需要改变 绑定的数据时，必须调用 setData 方法修改，才会触发页面更新，像这样： 12345678910Page(&#123; data: &#123; text: '这是一个页面' &#125;, onLoad: function() &#123; this.setData(&#123; text: 'this is page' &#125;) &#125;&#125;) 条件渲染和列表渲染 以下内容来自微信官方文档。 小程序使用 wx:if=&quot;&quot; 完成条件渲染，类似于 vue 的 v-if 1&lt;view wx:if=\"&#123;&#123;condition&#125;&#125;\"&gt; True &lt;/view&gt; 也可以用 wx:elif 和 wx:else 来添加一个 else 块： 123&lt;view wx:if=\"&#123;&#123;length &gt; 5&#125;&#125;\"&gt; 1 &lt;/view&gt;&lt;view wx:elif=\"&#123;&#123;length &gt; 2&#125;&#125;\"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。内置变量 index （数组遍历的下标）， item （数组遍历的每一项） 123&lt;view wx:for=\"&#123;&#123;items&#125;&#125;\"&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 1234567Page(&#123; items: [&#123; message: 'foo', &#125;,&#123; message: 'bar' &#125;]&#125;) 使用wx:for-item可以指定数组当前元素的变量名 使用wx:for-index可以指定数组当前下标的变量名： 123&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\" wx:for-index=\"idx\" wx:for-item=\"itemName\"&gt; &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;&lt;/view&gt; 事件绑定wxml 只是用 bind[eventName]=&quot;handler&quot; 语法绑定事件 1&lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt;&lt;text&gt;tap&lt;/text&gt;&lt;/view&gt; 12345Page(&#123; bindViewTap: function(e) &#123; console.log(e.taget) &#125;&#125;) 通过 data-* 和 e.target.dateset 传递参数 1&lt;view bindtap=\"bindViewTap\" data-test-msg=\"啦啦啦啦啦啦\" class=\"userinfo\"&gt;&lt;text&gt;tap&lt;/text&gt;&lt;/view&gt; 123456Page(&#123; bindViewTap: function(e) &#123; // 会自动转成驼峰式命名 console.log(e.taget.dataset.testMsg) // 啦啦啦啦啦啦 &#125;&#125;) 目前踩过的坑事件绑定中 e.target.dataset当在父组件绑定事件和参数，点击时又子组件冒泡事件到父组件，这个时候 e.target.dataset 为空 123&lt;view bindtap=\"bindViewTap\" data-test-msg=\"啦啦啦啦啦啦\" class=\"userinfo\"&gt; &lt;view&gt;&lt;text&gt;tap&lt;/text&gt;&lt;/view&gt;&lt;/view&gt; 12345Page(&#123; bindViewTap: function(e) &#123; console.log(e.taget.dataset.testMsg) // undefined &#125;&#125;) 在线图片加载不稳定在知乎日报这个项目上有大量图片需要从网上下载，这里 image 组件额显示显得极其不稳定，有很多的图片都显示不出来. 最后微信小程序现在还在内测阶段，有很多的问题需要完善，不过对于开发速度和体验来说还是不错的，期待正式发布的那一天。 资源 官方文档 开发工具下载 awesome-wechat-weapp","tags":[{"name":"wechat","slug":"wechat","permalink":"http://myronliu.com/tags/wechat/"}]},{"title":"vue 开发波纹点击特效组件","date":"2016-09-18T08:34:00.000Z","path":"2016/09/18/vue/vue_ripple/","text":"最近在使用 vue2 做一个新的 material ui 库，波纹点击效果在 material design 中被多次使用到，于是决定把它封装成一个公共的组件，使用时直接调用就好啦。 开发之前的思考常见的波纹点击效果的实现方式是监听元素的 mousedown 事件，在元素内部创建一个 波纹元素 ，并调整元素的 transform: scale(0); 到 transform: scale(1);, 通过计算点击的位置来设置 波纹元素 的大小和位置，以达到波纹扩散的效果。 我将组件分为两个部分， circleRipple.vue 和 TouchRipple.vue 各自实现不同的功能 circleRipple.vue 波纹扩散组件，完成波纹扩散的效果 TouchRipple.vue 监听 mouse 和 touch 相关事件，控制 circleRipple 的显示，位置。 circleRipple.vuecircleRipple 需要完成波纹扩展的效果，而且可以从外部控制它的大小和位置, 所以利用 vue 的 transition 动画完成效果, 提供 mergeStyle 、 color 、opacity 参数来从外部控制它的样式。实现代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;transition name=\"mu-ripple\"&gt; &lt;div class=\"mu-circle-ripple\" :style=\"styles\"&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;import &#123;merge&#125; from '../utils'export default &#123; props: &#123; mergeStyle: &#123; type: Object, default () &#123; return &#123;&#125; &#125; &#125;, color: &#123; type: String, default: '' &#125;, opacity: &#123; type: Number &#125; &#125;, computed: &#123; styles () &#123; return merge(&#123;&#125;, &#123;color: this.color, opacity: this.opacity&#125;, this.mergeStyle) &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt;@import \"../styles/import.less\";.mu-circle-ripple&#123; position: absolute; width: 100%; height: 100%; left: 0; top: 0; pointer-events: none; user-select: none; border-radius: 50%; background-color: currentColor; background-clip: padding-box; opacity: 0.1;&#125;.mu-ripple-enter-active, .mu-ripple-leave-active&#123; transition: transform 1s @easeOutFunction, opacity 2s @easeOutFunction;&#125;.mu-ripple-enter &#123; transform: scale(0);&#125;.mu-ripple-leave-active&#123; opacity: 0 !important;&#125;&lt;/style&gt; vue2 对于动画方面做了比较大的修改，除了把指令换成组件外，它还可以完成更复杂的动画效果，具体可以看这里 vue2 transition TouchRipple.vueTouchRipple 需要控制 circleRipple 的显示。完成以下内容： 监听 mouse 和 touch 相关事件， 控制 circleRipple 的显示。 通过点击事件 event 对象， 计算出 circleRipple 的大小和位置 如果频繁点击可能出现多个 circleRipple 首先，基本模板 + 数据模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;template&gt; &lt;!--最外层用div包裹--&gt; &lt;div @mousedown=\"handleMouseDown\" @mouseup=\"end()\" @mouseleave=\"end()\" @touchstart=\"handleTouchStart\" @touchend=\"end()\" @touchcancel=\"end()\"&gt; &lt;!--外层包裹防止波纹溢出--&gt; &lt;div :style=\"style\" ref=\"holder\"&gt; &lt;!--多个波纹用 v-for 控制--&gt; &lt;circle-ripple :key=\"ripple.key\" :color=\"ripple.color\" :opacity=\"ripple.opacity\" :merge-style=\"ripple.style\" v-for=\"ripple in ripples\"&gt;&lt;/circle-ripple&gt; &lt;/div&gt; &lt;!--利用slot分发实际内容--&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import circleRipple from './circleRipple'export default &#123; props: &#123; // 是否从中间扩散，设为false会从点击处扩散 centerRipple: &#123; type: Boolean, default: true &#125;, // 外层包裹的样式 style: &#123; type: Object, default () &#123; return &#123; height: '100%', width: '100%', position: 'absolute', top: '0', left: '0', overflow: 'hidden' &#125; &#125; &#125;, // 波纹颜色 color: &#123; type: String, default: '' &#125;, // 波纹透明度 opacity: &#123; type: Number &#125; &#125;, data () &#123; return &#123; nextKey: 0, // 记录下一个波纹元素的key值， 相当于uuid，不设置的话会使动画失效 ripples: [] // 波纹元素参数数组 &#125; &#125;, mounted () &#123; this.ignoreNextMouseDown = false // 防止既有 touch 又有 mouse点击的情况 &#125;, methods: &#123; start (event, isRippleTouchGenerated) &#123; // 开始波纹效果 &#125;, end () &#123; // 结束波纹效果 &#125;, handleMouseDown (event) &#123; // 监听 鼠标单击 &#125;, handleTouchStart (event) &#123; // 监听 touchstart 方法 &#125; &#125;, components: &#123; 'circle-ripple': circleRipple &#125;&#125;&lt;/script&gt; 开始和结束波纹效果增加一个波纹元素只需要在 ripple 增加一个 object 即可，不同的是当需要从点击处扩展时，需要计算一下波纹元素的大小和位置。 123456789101112131415161718192021222324&#123; // isRippleTouchGenerated 是否是touch 事件开始的 start (event, isRippleTouchGenerated) &#123; // 过滤 touchstart 和 mousedown 同时存在的情况 if (this.ignoreNextMouseDown &amp;&amp; !isRippleTouchGenerated) &#123; this.ignoreNextMouseDown = false return &#125; // 添加一个 波纹元素组件 this.ripples.push(&#123; key: this.nextKey++, color: this.color, opacity: this.opacity, style: this.centerRipple ? &#123;&#125; : this.getRippleStyle(event) // 不是从中心扩展的需要计算波纹元素的位置 &#125;) this.ignoreNextMouseDown = isRippleTouchGenerated &#125;, end () &#123; if (this.ripples.length === 0) return this.ripples.splice(0, 1) // 删除一个波纹元素 this.stopListeningForScrollAbort() // 结束 touch 滚动的处理 &#125;&#125; 因为 vue2 基于 Virtual DOM 的， 所以如果没有 key 在增加一个元素又同时删除一个元素的时候，dom tree并没有发生变化，是不会产生动画效果的。 监听 mousedown 和 touchstartmousedown 和 touchstart 处理上会有所不同，但都是用来启动波纹效果的， touch涉及到多点点击的问题，我们一般取第一个即可。 12345678910111213141516&#123; handleMouseDown (event) &#123; // 只监听鼠标左键的点击 if (event.button === 0) &#123; this.start(event, false) &#125; &#125;, handleTouchStart (event) &#123; event.stopPropagation() // 防止多个波纹点击组件嵌套 if (event.touches) &#123; this.startListeningForScrollAbort(event) // 启动 touchmove 触发滚动处理 this.startTime = Date.now() &#125; this.start(event.touches[0], true) &#125;&#125; touchmove控制当发生touchMove事件是需要判断是否，移动的距离和时间，然后结束小波纹点击小姑 1234567891011121314151617181920212223&#123; // touchmove 结束波纹控制 stopListeningForScrollAbort () &#123; if (!this.handleMove) this.handleMove = this.handleTouchMove.bind(this) document.body.removeEventListener('touchmove', this.handleMove, false) &#125;, startListeningForScrollAbort (event) &#123; this.firstTouchY = event.touches[0].clientY this.firstTouchX = event.touches[0].clientX document.body.addEventListener('touchmove', this.handleMove, false) &#125;, handleTouchMove (event) &#123; const timeSinceStart = Math.abs(Date.now() - this.startTime) if (timeSinceStart &gt; 300) &#123; this.stopListeningForScrollAbort() return &#125; const deltaY = Math.abs(event.touches[0].clientY - this.firstTouchY) const deltaX = Math.abs(event.touches[0].clientX - this.firstTouchX) // 滑动范围在 &gt; 6px 结束波纹点击效果 if (deltaY &gt; 6 || deltaX &gt; 6) this.end() &#125;&#125; 计算波纹的位置和大小需要从点击处扩散的波纹效果，需要计算波纹元素的大小和位置 123456789101112131415161718192021222324252627282930313233&#123; getRippleStyle (event) &#123; let holder = this.$refs.holder // 这个方法返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素各边与页面上边和左边的距离。 let rect = holder.getBoundingClientRect() // 获取点击点的位置 let x = event.offsetX let y if (x !== undefined) &#123; y = event.offsetY &#125; else &#123; x = event.clientX - rect.left y = event.clientY - rect.top &#125; // 获取最大边长 let max if (rect.width === rect.height) &#123; max = rect.width * 1.412 &#125; else &#123; max = Math.sqrt( (rect.width * rect.width) + (rect.height * rect.height) ) &#125; const dim = (max * 2) + 'px' return &#123; width: dim, height: dim, // 通过margin控制波纹中心点和点击点一致 'margin-left': -max + x + 'px', 'margin-top': -max + y + 'px' &#125; &#125;&#125; 使用由于 touchRipple 内部都是 position:absolute 布局，使用时，需要在外部加上 position:relative 1234567891011121314151617181920// listItem.vue&lt;a :href=\"href\" @mouseenter=\"hover = true\" @mouseleave=\"hover = false\" @touchend=\"hover = false\" @touchcancel=\"hover = false\" class=\"mu-item-wrapper\" :class=\"&#123;'hover': hover&#125;\"&gt; &lt;touch-ripple class=\"mu-item\" :class=\"&#123;'mu-item-link': link&#125;\" :center-ripple=\"false\"&gt; &lt;div class=\"mu-item-media\"&gt; &lt;slot name=\"media\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"mu-item-content\"&gt; // ... &lt;/div&gt; &lt;/touch-ripple&gt;&lt;/a&gt;&lt;style&gt;.mu-item-wrapper &#123; display: block; color: inherit; position: relative;&#125;&lt;/style&gt; 最后到这点击波纹组件就开发完了， 这些代码借鉴了 keen-ui 和 material-ui 的实现方式。","tags":[{"name":"vue","slug":"vue","permalink":"http://myronliu.com/tags/vue/"}]},{"title":"关于 vue 弹窗组件的一些感想","date":"2016-09-08T00:34:00.000Z","path":"2016/09/08/vue/vue_layer/","text":"最近是用 vue 开发了一套组件库 vue-carbon , 在开发过程对对于组件化的开发有一些感想，于是开始记录下这些。 弹窗组件一直是 web 开发中必备的，使用频率相当高，最常见的莫过于 alert，confirm，prompt .. 这些（曾经我们都会用alert来调试程序）, 不同的组件库对于弹窗的处理也是不一样的。在开发时需要考虑一下三点: 进入和弹出的动画效果。 z-index 的控制 overlay 遮盖层 关于动画vue 对于动画的处理相对简单，给组件加入css transition 动画即可 12345678910111213141516171819202122232425&lt;template&gt;&lt;div class=\"modal\" transition=\"modal-scale\"&gt; &lt;!--省略其它内容--&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;// ...&lt;/script&gt;&lt;style&gt;.modal-scale-transition&#123; transition: transform,opacity .3s ease;&#125;.modal-scale-enter,.modal-scale-leave &#123; opacity: 0;&#125;.modal-scale-enter &#123; transform: scale(1.1);&#125;.modal-scale-leave &#123; transform: scale(0.8);&#125;&lt;/style&gt; 外部可以由使用者自行控制，使用 v-if 或是 v-show 控制显示 z-index 的控制关于z-index的控制，需要完成以下几点 保证弹出框的 z-index 足够高能使 其再最外层 后弹出的弹出框的 z-index 要比之前弹出的要高 要满足以上两点， 我们需要以下代码实现 12345const zIndex = 20141223 // 先预设较高值const getZIndex = function () &#123; return zIndex++ // 每次获取之后 zindex 自动增加&#125; 然后绑定把 z-index 在组件上 1234567891011121314&lt;template&gt;&lt;div class=\"modal\" :style=\"&#123;'z-index': zIndex&#125;\" transition=\"modal-scale\"&gt; &lt;!--省略其它内容--&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; zIndex: getZIndex() &#125; &#125;&#125;&lt;/script&gt; overlay 遮盖层的控制遮盖层是弹窗组件中最难处理的部分, 一个完美的遮盖层的控制需要完成以下几点: 遮盖层和弹出层之间的动画需要并行 遮盖层的 z-index 要较小与弹出层 遮盖层的弹出时需要组件页面滚动 点击遮盖层需要给予弹出层反馈 保证整个页面最多只能有一个遮盖层（多个叠在一起会使遮盖层颜色加深） 为了处理这些问题，也保证所有的弹出框组件不用每一个都解决，所以决定利用 vue 的 mixins 机制，将这些弹出层的公共逻辑封装层一个 mixin ，每个弹出框组件直接引用就好。 vue-popup-mixin明确了上述所有的问题，开始开发 mixin, 首先需要一个 overlay (遮盖层组件) ; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div class=\"overlay\" @click=\"handlerClick\" @touchmove=\"prevent\" :style=\"style\" transition=\"overlay-fade\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; onClick: &#123; type: Function &#125;, opacity: &#123; type: Number, default: 0.4 &#125;, color: &#123; type: String, default: '#000' &#125; &#125;, computed: &#123; style () &#123; return &#123; 'opacity': this.opacity, 'background-color': this.color &#125; &#125; &#125;, methods: &#123; prevent (event) &#123; event.preventDefault() event.stopPropagation() &#125;, handlerClick () &#123; if (this.onClick) &#123; this.onClick() &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt;.overlay &#123; position: fixed; left: 0; right: 0; top: 0; bottom: 0; background-color: #000; opacity: .4; z-index: 1000;&#125;.overlay-fade-transition &#123; transition: all .3s linear; &amp;.overlay-fade-enter, &amp;.overlay-fade-leave &#123; opacity: 0 !important; &#125;&#125;&lt;/style&gt; 然后 需要一个 js 来管理 overlay 的显示和隐藏。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import Vue from 'vue'import overlayOpt from '../overlay' // 引入 overlay 组件const Overlay = Vue.extend(overlayOpt)const getDOM = function (dom) &#123; if (dom.nodeType === 3) &#123; dom = dom.nextElementSibling || dom.nextSibling getDOM(dom) &#125; return dom&#125;// z-index 控制const zIndex = 20141223 const getZIndex = function () &#123; return zIndex++ &#125;// 管理const PopupManager = &#123; instances: [], // 用来储存所有的弹出层实例 overlay: false, // 弹窗框打开时 调用此方法 open (instance) &#123; if (!instance || this.instances.indexOf(instance) !== -1) return // 当没有遮盖层时，显示遮盖层 if (this.instances.length === 0) &#123; this.showOverlay(instance.overlayColor, instance.overlayOpacity) &#125; this.instances.push(instance) // 储存打开的弹出框组件 this.changeOverlayStyle() // 控制不同弹出层 透明度和颜色 // 给弹出层加上z-index const dom = getDOM(instance.$el) dom.style.zIndex = getZIndex() &#125;, // 弹出框关闭方法 close (instance) &#123; let index = this.instances.indexOf(instance) if (index === -1) return Vue.nextTick(() =&gt; &#123; this.instances.splice(index, 1) // 当页面上没有弹出层了就关闭遮盖层 if (this.instances.length === 0) &#123; this.closeOverlay() &#125; this.changeOverlayStyle() &#125;) &#125;, showOverlay (color, opacity) &#123; let overlay = this.overlay = new Overlay(&#123; el: document.createElement('div') &#125;) const dom = getDOM(overlay.$el) dom.style.zIndex = getZIndex() overlay.color = color overlay.opacity = opacity overlay.onClick = this.handlerOverlayClick.bind(this) overlay.$appendTo(document.body) // 禁止页面滚动 this.bodyOverflow = document.body.style.overflow document.body.style.overflow = 'hidden' &#125;, closeOverlay () &#123; if (!this.overlay) return document.body.style.overflow = this.bodyOverflow let overlay = this.overlay this.overlay = null overlay.$remove(() =&gt; &#123; overlay.$destroy() &#125;) &#125;, changeOverlayStyle () &#123; if (!this.overlay || this.instances.length === 0) return const instance = this.instances[this.instances.length - 1] this.overlay.color = instance.overlayColor this.overlay.opacity = instance.overlayOpacity &#125;, // 遮盖层点击处理，会自动调用 弹出层的 overlayClick 方法 handlerOverlayClick () &#123; if (this.instances.length === 0) return const instance = this.instances[this.instances.length - 1] if (instance.overlayClick) &#123; instance.overlayClick() &#125; &#125;&#125;window.addEventListener('keydown', function (event) &#123; if (event.keyCode === 27) &#123; // ESC if (PopupManager.instances.length &gt; 0) &#123; const topInstance = PopupManager.instances[PopupManager.instances.length - 1] if (!topInstance) return if (topInstance.escPress) &#123; topInstance.escPress() &#125; &#125; &#125;&#125;)export default PopupManager 最后再封装成一个 mixin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import PopupManager from './popup-manager'export default &#123; props: &#123; show: &#123; type: Boolean, default: false &#125;, // 是否显示遮盖层 overlay: &#123; type: Boolean, default: true &#125;, overlayOpacity: &#123; type: Number, default: 0.4 &#125;, overlayColor: &#123; type: String, default: '#000' &#125; &#125;, // 组件被挂载时会判断show的值开控制打开 attached () &#123; if (this.show &amp;&amp; this.overlay) &#123; PopupManager.open(this) &#125; &#125;, // 组件被移除时关闭 detached () &#123; PopupManager.close(this) &#125;, watch: &#123; show (val) &#123; // 修改 show 值是调用对于的打开关闭方法 if (val &amp;&amp; this.overlay) &#123; PopupManager.open(this) &#125; else &#123; PopupManager.close(this) &#125; &#125; &#125;, beforeDestroy () &#123; PopupManager.close(this) &#125;&#125; 使用以上所有的代码就完成了所有弹出层的共有逻辑， 使用时只需要当做一个mixin来加载即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=\"dialog\" v-show=\"show\" transition=\"dialog-fade\"&gt; &lt;div class=\"dialog-content\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .dialog &#123; left: 50%; top: 50%; transform: translate(-50%, -50%); position: fixed; width: 90%; &#125; .dialog-content &#123; background: #fff; border-radius: 8px; padding: 20px; text-align: center; &#125; .dialog-fade-transition &#123; transition: opacity .3s linear; &#125; .dialog-fade-enter, .dialog-fade-leave &#123; opacity: 0; &#125;&lt;/style&gt;&lt;script&gt;import Popup from '../src'export default &#123; mixins: [Popup], methods: &#123; // 响应 overlay事件 overlayClick () &#123; this.show = false &#125;, // 响应 esc 按键事件 escPress () &#123; this.show = false &#125; &#125;&#125;&lt;/script&gt;","tags":[{"name":"vue","slug":"vue","permalink":"http://myronliu.com/tags/vue/"}]},{"title":"移动web开发中有用的css片段","date":"2016-09-01T07:47:00.000Z","path":"2016/09/01/移动web/mobile_css/","text":"在做移动 web 开发中有很多地方跟 PC 段是不一样的，需要不一样的 css reset， 或者使用flexbox布局，等等，这里就记录下移动 web 开发中有用的 css 片段。 css reset移动web中reset 除了常规的 Normalize.css 之外，还需要加上下面这些代码 1234567891011121314151617181920html&#123; -webkit-tap-highlight-color: rgba(0,0,0,0);/*去掉触摸遮盖层*/ -webkit-user-modify: read-write-plaintext-only; -webkit-user-select: none;/*禁止用户选择文字*/&#125;/*设置所有盒子大小计算边框内*/**:before,*:after &#123; box-sizing: border-box;&#125;/*消除输入框的阴影和边框*/input,textarea, select&#123; -webkit-appearance: none; appearance: none; outline: none; border: none;&#125; 消除 transition 动画闪屏移动 web 中常会使用到 transition 动画，在某些设备上会出现闪屏的现象，需要在样式加上下面这些 1234567.animate &#123; /* .... */ /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden;&#125; 弹性滚动ios 设备上设置弹性滚动属性，可以使滚动更加流畅 1234.scollable&#123; overflow: auto; -webkit-overflow-scrolling: touch;/*滚动touch*/&#125; 点击状态处理reset 关闭了点击高亮（因为会延迟），需要使用伪元素实现点击高亮效果 12345678910111213141516171819202122.active:before&#123; content: ''; width: 100%; height: 100%; position: absolute; left: 0; top: 0; background-color: @color; background-repeat: no-repeat; background-position: center; background-size: 100% 100%; opacity: 0; pointer-events: none; -webkit-transition: opacity 600ms; transition: opacity 600ms; /*加上动画显得更自然*/&#125;.active:active:before&#123; opacity: 1; -webkit-transition: opacity 150ms; transition: opacity 150ms;&#125; 1px边框处理移动端会有很多的高清屏，导致 border-width: 1px 的边框显得特别粗，所以需要使用伪元素模拟边框，检测不同的屏幕然后缩小高度，使其像头发丝一样细. 12345678910111213141516171819202122/*border 在底部*/.has-border:after&#123; content: ''; position: absolute; right: 0; top: 0; left: auto; bottom: auto; width: 1px; height: 100%; background-color: rgba(0, 0, 0, .12); display: block; z-index: 15;&#125;html.pixel-ratio-2 &amp; &#123; -webkit-transform: scaleX(0.5); transform: scaleX(0.5);&#125;html.pixel-ratio-3 &amp; &#123; -webkit-transform: scaleX(0.33); transform: scaleX(0.33);&#125; 通过 js 检测 devicePixelRatio 然后 html 加上相应的样式 1234567891011// 处理retina屏幕显示效果var classNames = []var pixelRatio = window.devicePixelRatio || 1classNames.push('pixel-ratio-' + Math.floor(pixelRatio))if (pixelRatio &gt;= 2) &#123; classNames.push('retina')&#125;var html = document.getElementsByTagName('html')[0]classNames.forEach((className) =&gt; html.classList.add(className)) 使用 fastclick 之后，label点击的问题为了解决 点击事件300ms延迟 的问题, 都会引入 fastclick 库, 但是会发现当 label 内部有其它元素时不能给表单元素聚焦了。 12345&lt;label&gt; &lt;input type=\"text\"/&gt; &lt;!--这个时候点击 span标签中的内容 input无法获取焦点--&gt; &lt;span&gt;text&lt;/span&gt;&lt;/label&gt; 需要使用 pointer-event 让 label中元素的点击事件都冒泡到 label 上再执行 1234/*这里是示例代码， 实际使用最好制定 className*/label *&#123; pointer-events: none;&#125; 关于布局移动端中 对于 flexbox 的支持已经很好，flexbox 是布局神器，像页面 上中下这种结构的布局很容易就实现了。 12345&lt;div class=\"page\"&gt; &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920.page&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; display: flex; flex-direction: column; justify-content: center; align-items: flex-start;&#125;.header,.footer&#123; width: 100%; height: 56px&#125;.content&#123; flex: 1; width: 100%;&#125; 另外阮一峰老师也写过 flexbox 入门教程","tags":[{"name":"css","slug":"css","permalink":"http://myronliu.com/tags/css/"},{"name":"移动web","slug":"移动web","permalink":"http://myronliu.com/tags/移动web/"}]},{"title":"ES6的二三事(二)-模块化","date":"2016-08-20T16:54:00.000Z","path":"2016/08/21/javscript/ES6的二三事(二)－模块化/","text":"在之前的 javascript 中一直是没有模块系统的，前辈们为了解决这些问题，提出了各种规范, 最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。而 ES6 中提供了简单的模块系统，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 基本用法es6 中新增了两个命令 export 和 import , export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个 变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。 123456789// math.jsexport const add = function (a, b) &#123; return a + b&#125;export const subtract = function (a, b) &#123; return a - b&#125; 使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。 12345// main.jsimport &#123; add, subtract &#125; from './test.js'add(1, 2)substract(3, 2) export 详细用法上面介绍了模块化最基础的用法，export 不止可以导出函数，还可以导出对象，类，字符串等等 12345678910export const obj = &#123; test1: ''&#125;export const test = ''export class Test &#123; constructor() &#123; &#125;&#125; export的写法，除了像上面这样，还有另外一种。 12345678let a = 1let b = 2let c = 3export &#123; a, b, c&#125; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 通过 as 改变输出名称 123456789// test.jslet a = 1let b = 2let c = 3export &#123; a as test, b, c&#125; 1import &#123; test, b, c&#125; from './test.js' // 改变命名后只能写 as 后的命名 上面啊的写法中，import 中需要指定加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 export default 指定默认输出, import 无需知道变量名就可以直接使用 12345// test.jsexport default function () &#123; console.log('hello world')&#125; 123import say from './test.js' // 这里可以指定任意变量名say() // hello world 有了export default命令，加载模块时就非常直观了，以一些常用的模块为例 123import $ from 'jQuery' // 加载jQuery 库import _ from 'lodash' // 加载 lodashimport moment from 'moment' // 加载 moment import 详细用法import 为加载模块的命令，基础使用方式和之前一样 123456// main.jsimport &#123; add, subtract &#125; from './test'// 对于export default 导出的import say from './test' 通过 as 命令修改导入的变量名123import &#123;add as sum, subtract&#125; from './test'sum (1, 2) 加载模块的全部除了指定输出变量名或者 export.default 定义的导入， 还可以通过 * 号加载模块的全部. 123456789// math.jsexport const add = function (a, b) &#123; return a + b&#125;export const subtract = function (a, b) &#123; return a - b&#125; 1234import * as math from './test.js'math.add(1, 2)math.subtract(1, 2) 开始使用 ES6上面介绍了，es6 中模块的使用方式，但是现在es6的模块化，无论在浏览器端还是 node.js 上都没有得到很好的支持，所以需要，一些转码的工具。使我们可以用es6的方式来编码，最后输出es5的代码。 这里推荐一款基于 es6 模块化方式的打包神器 rollup，它使用 Tree-shaking 的技术打包，基本可以做到零冗余的代码，而且配置简单，打包速度也够快。 安装 rollup首先在 package.json 中加上 rollup 打包依赖的包 123456789101112&#123; // ... \"devDependencies\": &#123; \"babel-core\": \"^6.13.0\", \"babel-preset-es2015-rollup\": \"^1.1.1\", \"rollup\": \"^0.34.3\", \"rollup-plugin-babel\": \"^2.6.1\", \"rollup-plugin-commonjs\": \"^3.3.1\", \"rollup-plugin-node-resolve\": \"^2.0.0\", \"rollup-plugin-uglify\": \"^1.0.1\" &#125;&#125; 编写打包程序下面是我的打包程序1234567891011121314151617181920212223242526// build.jsvar rollup = require('rollup');var babel = require('rollup-plugin-babel'); // babel 插件var uglify = require('rollup-plugin-uglify'); // js 混淆压缩插件var npm = require('rollup-plugin-node-resolve'); // 使用第三方包依赖var commonjs = require('rollup-plugin-commonjs'); // CommonJS模块转换为ES6rollup.rollup(&#123; entry: 'src/index.js', //入口文件 plugins: [ // 插件配置 npm(&#123; jsnext: true, main: true &#125;), commonjs(), uglify(), babel(&#123; exclude: 'node_modules/**', presets: [ \"es2015-rollup\" ] &#125;) ]&#125;).then(function(bundle) &#123; // 打包之后生成一个 `budble` 把它写入文件即可 bundle.write(&#123; // 转化格式 cjs 代表 commonJs, 还支持 iife, amd, umd, es6 .... format: 'cjs', banner: 'si_log.js v0.1.1', //文件顶部的广告 dest: 'dist/si_log_common.js' &#125;);&#125;); 在 package.json 中加上执行脚本1234567&#123; // ... \"scripts\": &#123; // ... \"build\": \"node build.js\" &#125;,&#125; 然后，执行命令1npm run build ok 到这里打包就都结束了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://myronliu.com/tags/ES6/"}]},{"title":"ES6的二三事(一)","date":"2016-08-16T00:25:00.000Z","path":"2016/08/16/javscript/ES6的二三事(一)/","text":"最近都在开发 react-native 和 Vue 的项目，接触多了 ES6 代码，相较于之前的一脸懵逼，显示觉得 ES6 简直妙不可言，于是赶紧写写博客总结下知识点和经验。 简介 ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 标准的制定者有计划，以后每年发布一次标准，使用年份作为版本。因为ES6的第一个版本是在2015年发布的，所以又称ECMAScript 2015（简称ES2015）。 let 和 const 命令在之前的 javascript 开发中，我们使用 var 定义变量，这种方式定义的变量有几个问题: 没有块级作用域 存在变量提升 没有常量的定义 为了解决这些问题， ES6 新增了 let 命令来定义变量， const 命令来定义常量, 如果最 javascript 作用域不太了解的，可以看我之前的博客 javascript作用域和闭包 块级作用域javascript 之前用 var 定义的变量是没有块级作用域的，在 if 或 for 语句块中定义的变量，在外面仍可以访问到. 12345678if (true) &#123; var test = 'this is test msg'&#125;console.log(test) // this is test msgfor (var i = 0; i &lt; 5; i++) &#123;&#125;console.log(i) // 5 是用 let 定义变量之后，就可以有块级作用域了. 1234for (let i = 0; i &lt; arr.length; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined 不存在变量提升12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 上面代码中，变量 foo 用 var 命令声明，会发生变量提升，即脚本开始运行时，变量 foo 已经存在了，但是没有值，所以会输出undefined。变量 bar 用 let 命令声明，不会发生变量提升。这表示在声明它之前，变量 bar 是不存在的，这时如果用到它，就会抛出一个错误。 常量ES6之前，没有常量的定义，只能像这样写 1var SIZE = 10; // 用大写定义变量约定为常量，后面不可修改 以上的做法还是会有后面被人修改的隐患， 于是ES6中有了 const 定义常量 123const SIZE = 10;SIZE = 4; // 报错 变量的结构赋值 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6 中允许可以写成这样 1var [a, b, c] = [1, 2, 3]; 上面是在数组提取值，除此之外，ES6还支持对象中提取值 1234var &#123;a, b, c&#125; = &#123;a:1, b: 2, c: 3&#125;// a = 1// b = 2// c = 3 箭头函数ES6允许使用“箭头”（=&gt;）定义函数。 1234567var fun = v =&gt; v;// 等同于var fun = function (v) &#123; return v;&#125; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 另外用 =&gt; 定义的函数，是绑定了 this 对象的 1234567var f = () =&gt; 5// 等同于var f = function () &#123; return 5;&#125;.bind(this) 除此之外箭头函数使用还需要注意以下三点： 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 不可以使用yield命令，因此箭头函数不能用作Generator函数。 classJavaScript语言的传统方法是通过构造函数，定义并生成新对象 1234567891011function Person (name, age) &#123; this.name = name; this.age = age;&#125;// 利用原型绑定方法，不会每次实例化都创建，提升性能Person.prototype.say = function () &#123; console.log('My name is ' + this.name + ', I`m ' + this.age + ' years old');&#125;var hong = new Person('小红', 16) 这种定义的方式有存在以下问题： 和 java、c# 等传统面向对象语言，定义方式差别很大，容易让然产生困惑 没有继承机制，只能通过原型链模拟，需要自己实现 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class (class在之前的版本一直是保留关键字)关键字，可以定义类。 123456789class Person &#123; constructor (name, age) &#123; this.name = name; this.age = age; &#125; say () &#123; console.log('My name is ' + this.name + ', I`m ' + this.age + ' years old'); &#125;&#125; 使用方式跟之前一样 1var hong = new Person('小红', 16) 可以通过 extends 关键字继承类 12345class Man extends Person &#123; constructor (name, age) &#123; super(name, age) // 通过 super 调用父类的同名方法 &#125;&#125; static 关键字定义静态属性和方法 12345678910111213141516171819class Person &#123; constructor (name, age) &#123; this.name = name; this.age = age; &#125; say () &#123; console.log('My name is ' + this.name + ', I`m ' + this.age + ' years old'); &#125; static test = '111' static desc () &#123; console.log('this is person class'); &#125;&#125;console.log(Person.test) // 111Person.desc()var hong = new Person('小红', 16) hong.desc() // 报错，没有这个方法 基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://myronliu.com/tags/ES6/"}]},{"title":"node 和 npm 版本升级","date":"2016-08-12T06:00:00.000Z","path":"2016/08/12/前端工具/node_npm_update/","text":"今天看 vue-hackernews-2.0 发现必须先把 node 版本升级 6.0以上, 不想再重新下载一次node，于是找到了一个超简单的方法升级 node 和 npm。 node 升级首先安装 n 模块， 它是专门管理node 版本的 1npm install -g n 然后，升级node到最新的稳定版 1n stable 没错就是这么简单, 后面也可以直接跟版本号哦 1n 6.3.1 npm 升级npm 无需安装任何东西就可以完成升级 1npm install -g npm","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://myronliu.com/tags/前端工具/"}]},{"title":"javascript单元测试实践","date":"2016-08-10T06:16:00.000Z","path":"2016/08/10/前端工具/javascript_unit/","text":"最近往 npm 上发布一些包，为了保证后续运行没有很严重的bug，需要给程序加一些单元测试，看下整体的运行的情况，参照了最近使用的 vue-cli 生成项目的测试部分代码，使用 karma + mocha + phantomjs + chai 完成了整个项目的单元测试工作。 测试组件的介绍测试组件选取karma为测试管理工具，mocha为测试库，chai为断言库，phantomjs为测试浏览器。 Karma 是一个基于nodejs的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控(Watch)文件的变化，然后自行执行，通过console.log显示测试结果。 Mocha 是一个基于nodejs和浏览器集合的各种特性的JavaScript测试库，并且让异步测试变得简单，支持TDD(测试驱动开发)和BDD(行为驱动开发)，在测试中捕获到异常时，会给出灵活准确的报告。 Chai 是一个基于nodejs的断言库，并且完美支持各种主流的JavaScript测试框架。 Phantomjs 是一个无页面的浏览器，由于不需要渲染页面，网页的运行时间会大大缩短，该浏览器适合用于测试。 环境搭建首先新建了一个 testDemo 的项目，文件结构大致如下 src 源码目录,这里没有源码，可以不用管 package.json 定义文件 test 测试目录，所有跟测试有关的文件都放在这 unit 单元测试目录 karma.conf.js karma 的配置文件 specs 所有的测试代码存放在这里 安装依赖包需要安装下面这些包 12345678910111213&#123; // ... \"devDependencies\": &#123; \"chai\": \"^3.5.0\", \"karma\": \"^1.1.2\", \"karma-chai\": \"^0.1.0\", \"karma-mocha\": \"^1.1.1\", \"karma-phantomjs-launcher\": \"^1.0.1\", \"karma-spec-reporter\": \"0.0.26\", \"mocha\": \"^3.0.2\", \"phantomjs-prebuilt\": \"^2.1.11\" &#125;&#125; 编写karma.conf.js12345678module.exports = function(config) &#123; config.set(&#123; browsers: ['PhantomJS'], frameworks: ['mocha', 'chai'], reporters: ['spec'], files: ['./specs/*.spec.js'] &#125;);&#125; browsers 配置浏览器，这里使用 PlantomJS frameworks 使用的测试框架 reporters 那些报告类型 files 测试用例文件， 这里是specs文件夹下所有的以 .spect.js 结尾的文件 编写测试用例mocha的语法和 Jasmine 类似，像下面这样定义测试用例 1234567// 定义一类测试用例describe('test', function () &#123; // 单个测试用例定义 it('test hello world', function () &#123; expect('hello world').to.equal('hello world') //断言 &#125;)&#125;); 然后我们在 package.json 中加上运行脚本 1234567&#123; // ... \"scripts\": &#123; \"test\": \"karma start test/unit/karma.conf.js --single-run\" &#125; // ...&#125; 执行命令 npm run test 12345678910111213&gt; test-demo@1.0.0 test /Users/liuyuyang/Documents/code/testDemo&gt; karma start test/unit/karma.conf.js --single-run10 08 2016 15:05:39.458:INFO [karma]: Karma v1.1.2 server started at http://localhost:9876/10 08 2016 15:05:39.463:INFO [launcher]: Launching browser PhantomJS with unlimited concurrency10 08 2016 15:05:39.473:INFO [launcher]: Starting browser PhantomJS10 08 2016 15:05:40.464:INFO [PhantomJS 2.1.1 (Mac OS X 0.0.0)]: Connected on socket /#II3WWLgZIkE_I_7tAAAA with id 88502730 test ✓ test hello worldPhantomJS 2.1.1 (Mac OS X 0.0.0): Executed 1 of 1 SUCCESS (0.005 secs / 0.001 secs)TOTAL: 1 SUCCESS 到这里，测试结束，可以看到我们总共就只有一个单元测试用例，并且通过. 只是介绍了，javascript测试环境的搭建，以及最简单的测试用例的写法，更多的api和单元测试的写法，大家可以参加官网 资源Karma 官网 Mocha 官网 Chai 官网","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://myronliu.com/tags/前端工具/"},{"name":"karma","slug":"karma","permalink":"http://myronliu.com/tags/karma/"},{"name":"mocha","slug":"mocha","permalink":"http://myronliu.com/tags/mocha/"},{"name":"chai","slug":"chai","permalink":"http://myronliu.com/tags/chai/"}]},{"title":"npm 发布一个自己的包","date":"2016-08-09T00:28:36.000Z","path":"2016/08/09/前端工具/2016-08-09/","text":"NPM 是 node 自带的包管理工具, 我们在平时项目提炼出许多重用性比较强的代码，把这些代码整合成一个模块发布到npm社区，可以让自己模块做更好版本管理(不会因为自己某天改了一行代码就导致所有依赖项目歇菜)，新建项目的时候也不用copy代码这种粗糙的方法引入。 最近在npm上发布了两个包 si-log, si-store package.json要发布自己的包，需要有 package.json 文件(现在的项目应该都有了吧), 如果没有需要在项目目录下执行 npm init ，初始化完成后，会看到 package.json 文件内容像这样 12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;si-store&quot;, // 包的名称 &quot;version&quot;: &quot;0.1.1&quot;, // 版本 &quot;description&quot;: &quot;基于Web Storage的缓存库&quot;, // 介绍 &quot;main&quot;: &quot;dist/si-store-common.js&quot;, // 入口文件 // 代码托管信息 (目前是在github下) &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/aa953788477/store.js.git&quot; &#125;, // 关键字， 便于搜索 &quot;keywords&quot;: [ &quot;store&quot; ], // 作者 &quot;author&quot;: &quot;Myron Liu&quot;, //开源协议 &quot;license&quot;: &quot;MIT&quot;, // 提bug的页面 默认是github 的 issues &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/aa953788477/store.js/issues&quot; &#125;, // 主页 &quot;homepage&quot;: &quot;https://github.com/aa953788477/store.js#readme&quot;,&#125; 采用模块化方式编码node 包使用遵循模块化方案(commonJS), 如果使用到了babel转码，也可以使用es6的语法发布 12345678910111213// si-store/index.jsimport Store from './Store'import &#123;register&#125; from './storage/index.js'let store = new Store()store.version = '0.1.1'store.create = function (options) &#123; return new Store(options)&#125;store.register = registerexport default store 编写 README.mdreadme 是介绍你的包，需要介绍你的包解决了那些问题，最基本的使用方式是怎么样的，有那些api,像这样 si-store 一个基于 Web Storage 的存储库，提供简单的api操作，可以设置缓存时间 安装 用 npm 安装 1npm install si-store --save 直接在 script 标签中导入，先要在github 上下载代码,然后： 1&lt;script src=\"si-store.js\" charset=\"utf-8\"&gt;&lt;/script&gt; 开始使用 ….. API ….. License MIT Copyright (c) 2016 myron README.md 文件要把你的包使用方法写清楚，这样可以增加你项目的star哦. 发布首先把代码全部提交到github上，然后生成tag, 使用tag做版本管理 123git push git tag 0.1.0 git push --tag publish然后执行 publish 命令即可 1npm publish 这样我们的包就发布完成了，可以上 NPM 官网 上搜索下自己包是否存在， 后续更新当修复了bug，或者增加了一些新的功能后需要重新发布这个包，首先，修改 package.json 中version,然后生成新的 tag 发布. 123git tag 0.1.1git push --tagnpm publish 最好新建一个CHANGELOG.md 文件，记录下版本更新了那些东西。","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://myronliu.com/tags/前端工具/"},{"name":"npm","slug":"npm","permalink":"http://myronliu.com/tags/npm/"}]},{"title":"使用 rollup 打包你的 ES6 代码","date":"2016-08-07T09:07:00.000Z","path":"2016/08/07/前端工具/2016-08-07/","text":"Rollup 是下一代的 javascript 打包器，它使用 tree-shaking 的技术使打包的结果只包括实际用到的 exports。 使用它打包的代码，基本没有冗余的代码，减少了很多的代码体积， 它的官网上有打包的实例代码 Rollup.js 官网。 开始使用跟 webpack rollup可以以命令行和 javascript 调用两种方式，这里只介绍用javascript的调用的这种方式。首先我们安装一些 rollup 使用到的module, 在 package.json 中加上这些 123456789101112&#123; // ... \"devDependencies\": &#123; \"babel-core\": \"^6.13.0\", \"babel-preset-es2015-rollup\": \"^1.1.1\", \"rollup\": \"^0.34.3\", \"rollup-plugin-babel\": \"^2.6.1\", \"rollup-plugin-commonjs\": \"^3.3.1\", \"rollup-plugin-node-resolve\": \"^2.0.0\", \"rollup-plugin-uglify\": \"^1.0.1\" &#125;&#125; 编写打包的代码建一个 build.js 文件，内部代码可以像这样 12345678910111213141516171819202122var rollup = require('rollup');var babel = require('rollup-plugin-babel');var uglify = require('rollup-plugin-uglify');var npm = require('rollup-plugin-node-resolve');var commonjs = require('rollup-plugin-commonjs');rollup.rollup(&#123; entry: 'src/index.js', plugins: [ npm(&#123; jsnext: true, main: true &#125;), commonjs(), babel(&#123; exclude: 'node_modules/**', presets: [ \"es2015-rollup\" ] &#125;) ]&#125;).then(function(bundle) &#123; bundle.write(&#123; format: 'cjs', banner: banner, dest: 'dist/si_log_common.js' &#125;);&#125;); 如果需要同时 输出 commonJS 规范和 UMD 规范的代码只要这样既可 123456789101112131415161718192021222324252627282930313233343536373839rollup.rollup(&#123; entry: 'src/index.js', plugins: [ npm(&#123; jsnext: true, main: true &#125;), commonjs(), babel(&#123; exclude: 'node_modules/**', presets: [ \"es2015-rollup\" ] &#125;) ]&#125;).then(function(bundle) &#123; bundle.write(&#123; format: 'cjs', banner: banner, dest: 'dist/si_log_common.js' &#125;); rollup.rollup(&#123; entry: 'src/index.js', plugins: [ npm(&#123; jsnext: true, main: true &#125;), uglify(), // 加入压缩代码 commonjs(), babel(&#123; exclude: 'node_modules/**', presets: [ \"es2015-rollup\" ] &#125;) ] &#125;).then(function(bundle) &#123; bundle.write(&#123; // output format - 'amd', 'cjs', 'es6', 'iife', 'umd' format: 'umd', moduleName: 'siLog', sourceMap: true, dest: 'si_log.js' &#125;); &#125;)&#125;).catch(function(err)&#123; console.log(err);&#125;); 最后在 package.json 中 加载scripts使用: 1234567&#123; // ... \"scripts\": &#123; // ... \"build\": \"node build/build.js\" &#125;,&#125; 然后执行命令 1npm run build 这样打包的操作就结束了，rollup打包的代码提交较小，相比 webpack rollup 最后输出的代码，非常的整洁，结构清晰。 近期bug解决最近 babel-preset-es2015-rollup 这个插件可能有问题，如果打包的时候发现报错 1[Error: It looks like your Babel configuration specifies a module transformer. Please disable it. If you&apos;re using the &quot;es2015&quot; preset, consider using &quot;es2015-rollup&quot; instead. See https://github.com/rollup/rollup-plugin-babel#configuring-babel for more information] 只要执行以下命令即可: 1npm install babel-preset-es2015@6.13.0","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://myronliu.com/tags/前端工具/"},{"name":"rollup","slug":"rollup","permalink":"http://myronliu.com/tags/rollup/"}]},{"title":"react-native 给android端设置启动图","date":"2016-07-22T14:45:33.000Z","path":"2016/07/22/react-native/react-native_launch/","text":"公司的 环保头条 安卓端，全部使用 react-native , 相对之前的webapp 程序, 它的动画性能更好，更加贴近于原生的体验。 app功能开发基本完成后，发现一个很严重的问题，在app启动的时候会有很明显的白屏现象，不同的机型不同（cpu好的白屏时间短），大概1s到2s的时间。 为了解决这个问题，找了很多的资料，参考了 ReactNative安卓首屏白屏优化， 也并没有解决掉启动慢点问题 ， 原因是全react-native的应用，内存换效率的做法并不起作用。于是我决定曲线就够，在app启动时先展示一张背景图片，当启动后隐藏。 首先在 android/app/src/main/res/drawable-hdpi 里加上一个图片作为程序启动图 (名称随意，例如：splash.png) 然后修改 android/app/src/main/res/values/styles.xml 1234&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- 这里将刚刚那张图片设置为背景图片， splash对应图片名称 --&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/splash&lt;/item&gt;&lt;/style&gt; 最后修改我们的 react-native 顶层的容器，将它覆盖整个窗口 12345678&lt;View style=&#123;styles.container&#125;&gt;&lt;/View&gt;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#FFF' //背景色根据自己的需求来 &#125;&#125;) ok, 到这一步， 启动应用看看，会发现已经没有白屏了，会有一张覆盖全屏的启动图等待。 在 安卓5.0 以上会有沉浸式状态栏闪烁的问题，原因是，react-native默认是不设置状态栏的，所以我们需要在 MainActivity.java 中增加如下代码： 12345678910// 这里重写 createRootView 方法保证在耗时操作前完成状态栏设置@Overrideprotected ReactRootView createRootView() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; Window window = getWindow(); // 设置为沉浸式状态栏 window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; return super.createRootView();&#125; 到此，就全部完成啦，妈妈再也不用担心我的 app 启动白屏啦！","tags":[{"name":"移动端","slug":"移动端","permalink":"http://myronliu.com/tags/移动端/"},{"name":"react-native","slug":"react-native","permalink":"http://myronliu.com/tags/react-native/"}]},{"title":"react-native 开始走向mobile开发","date":"2016-07-17T01:38:24.000Z","path":"2016/07/17/react-native/react-native start/","text":"从去年开发接触移动端web开发，做了许多的webapp程序，嵌入原生程序中的表现都不太好，老是会卡顿。也尝试过许多的hybird解决方案， phoneGap 和 H5+ 这两者都是以 webview 为核心的开发。由于andorid系统的原因，变现都不太好（IOS上还是很流畅的）。 去年下半年开始关注 react-native, 一直也没有机会正式拿来开发, 最近公司要开发android版的 环保头条, 决定使用react-native来开发。体验之后性能的确是比webview的方式好太多。 所以决定记录一下react-native 应用开发的一些知识点 一、配置开发环境这个环境配置，官方文档给的很全我就不多做赘述了，按照 开始使用React Native 文档配置就可以了。 二、应用结构使用命令 react-native init 生成项目之后会有一个这样的文件结构 android/ios 存放的是双平台的代码，如果不需要加载原生模块，这两个文件夹中的文件就可以不用管 node_modules node模块 src 这个是自己建的目录，用于存放项目源码 index.[ios/android].js 启动时会根据平台运行不同的js 剩下的就都是配置文件 src 下是项目结构 actions/store/reducers 是redux相关的 configs/contants/images 配置文件和图片 serices 请求的相关的js components 组件 layouts 页面 三、用JSX语法构建页面ui构建成功之后，打开 index.android.js , 会发现render方法下这样的代码 123456789101112131415 &lt;View style=&#123;styles.container&#125; &gt; &lt;Nav title=\"关于\" router=&#123;this.props.router&#125;&gt;&lt;/Nav&gt; &lt;View style=&#123;styles.wrapper&#125;&gt; &lt;View style=&#123;styles.main&#125;&gt; &lt;Image style=&#123;styles.logo&#125; source=&#123;require('../images/logo.png')&#125;/&gt; &lt;Text style=&#123;styles.title&#125;&gt;环保头条&lt;/Text&gt; &lt;Text style=&#123;styles.subTitle&#125;&gt;您关心的就是头条&lt;/Text&gt; &lt;Text style=&#123;styles.version&#125;&gt;当前版本: V1.0 (Build:42)&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.footer&#125;&gt; &lt;Text style=&#123;styles.agreement&#125;&gt;用户协议&lt;/Text&gt; &lt;Text style=&#123;styles.copyRight&#125;&gt;技术支持：深圳博安达信息技术股份有限公司&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&lt;/View&gt; react 是基于虚拟dom的设计， 所谓虚拟dom，就是讲所有的 在view和逻辑之间，抽象出的对象，最后将这些对象解析成页面，不限web 或者原生，只是给出不同的实现就可以了。 如果不用jsx, react的语法写起来就是这样的 123React.createElement('View', &#123; style: &#123;&#125;&#125;, React.createElement('View')) 这么一看还是jsx方便，虽然网上有很多抨击jsx 的言论， 但是jsx 对于虚拟DOM 来说仍然是最好的一种方式， Vue2.0也用jsx了，虽然也保留了template的方式，但是尤大大也说了很多情况还是要使用jsx的。 最后，jsx 只是一种便于在js里写虚拟dom对象的语法而已，并没有什么特别的，还是很容易上手的。 jsx写法看这里 四、stylesheet 样式管理用了react-native就是不能像web开发一样愉快的写样式了， react-native 也提供了自己的样式定义的方法,使用 flexbox 布局，也支持 absolute觉得定位，基本和 css中一直 1234567891011121314151617const styles = StyleSheet.create(&#123; container: &#123; backgroundColor: 'white', width: width, height: height, position: 'relative' &#125;, wrapper: &#123; flex: 1, paddingTop: 50, paddingBottom: 80, alignItems: 'center', justifyContent: 'space-between' &#125; &#125;) &lt;View style=&#123;styles.container&#125;/&gt; 关于flexbox布局，阮一峰老师写过一篇详细的教程 Flex 布局教程：语法篇 react-native也并不是什么属性都支持，具体到每一个组件，例如 : 对于字体相关的样式 fontSize， color,这些只有Text 支持，而Text组件并不支持width和height这些组件。 五、redux管理你的appreact是通过状态的变化来改变页面的展示，每一个组件都有内部状态，当用户点击页面或者滑动的时候都会触发事件，对应的改变状态，更新页面展示。 如果没有状态管理的话，每一个组件就是相对独立，组件之前有交互变得很难, 例如：子组件中的一个操作，需要改变父组件的状态，这种场景控制起来很麻烦。 redux就是问了解决这种问题而生的框架，整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 页面中的组件发生事件，就产生一个 action , action将参数转给 reducer ， reducer 进过逻辑处理返回新的 state redux响应 state变化，来更新页面。 一旦使用 redux 就尽量不要在组件内部创建 state , 一个组件的标准定义应该如下: props 参数，根据不同的参数展示不同页面 action 组件中响应用户操作产生action,经redux修改状态 传入新的 props 响应props改变，更新页面。 六、网络请求 fetch React Native的目标之一是创造一个实验场，让我们可以实验不同的技术和一些疯狂的想法。因为浏览器环境还不够灵活，我们除了自己实现整个技术栈以外别无选择。其中有些部分我们没有刻意修改，而且希望尽可能地忠实于浏览器的API。网络API就是一个典型的例子。 使用方法 123fetch('https://mywebsite.com/endpoint/').then(function(res)&#123; return res.json()&#125;) fetch 是一个基于异步处理 Promise 的设计，更加的方便好用，现在浏览器环境也支持了（仅谷歌）, 第二的参数是可选的，用于配置一些请求参数，例如下面这样发送一个 post 请求 1234567fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125;, body: 'key1=value1&amp;key2=value2'&#125;) 更多 fetch 和 Promise 讲解看这里就好啦： JavaScript Fetch API Promise对象 另外 react-native 还支持 XMLHttpRequest 和 WebSocket, 网络 七、Navigator 不同场景（页面）间进行切换之前做webapp的时候最难搞的就是不同场景间的切换，虽说都有router和场景动画，但是很难分清楚，前进和返回的不同动画， 也没有手势返回，就算模拟出来了这两者，性能也不一定好。 在 react-native 中提供 Navigator 组件， 用来控制不同页面间的切换, 基本使用方式如下 1234567891011121314151617181920&lt;Navigator initialRoute=&#123;&#123;name: 'My First Scene', index: 0&#125;&#125; renderScene=&#123;(route, navigator) =&gt; &lt;MySceneComponent name=&#123;route.name&#125; onForward=&#123;() =&gt; &#123; var nextIndex = route.index + 1; navigator.push(&#123; name: 'Scene ' + nextIndex, index: nextIndex, &#125;); &#125;&#125; onBack=&#123;() =&gt; &#123; if (route.index &gt; 0) &#123; navigator.pop(); &#125; &#125;&#125; /&gt; &#125; /&gt; 在实际使用中，我们可以配合自定义的router对象，封装的更加完美一些 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Router &#123; constructor(navigator) &#123; this.navigator = navigator this.exitflag = false if (Platform.OS === 'android') &#123; BackAndroid.addEventListener('hardwareBackPress', ()=&gt; &#123; const routesList = this.navigator.getCurrentRoutes() const currentRoute = routesList[routesList.length - 1] if (currentRoute.name !== 'main') &#123; navigator.pop() return true &#125; else if (!this.exitflag) &#123; this.exitflag = true ToastAndroid.show('再按一次退出！', ToastAndroid.SHORT) setTimeout(() =&gt; &#123; this.exitflag = false &#125;, 3000) return true &#125; return false &#125;) &#125; &#125; push(props = &#123;&#125;, route) &#123; this.exitflag = false let routesList = this.navigator.getCurrentRoutes() let nextIndex = routesList[routesList.length - 1].index + 1 route.props = props route.index = nextIndex route.sceneConfig = route.sceneConfig ? route.sceneConfig : CustomSceneConfigs.customPushFromRight route.id = _.uniqueId() route.component = connectComponent(route.component) this.navigator.push(route) &#125; pop() &#123; this.navigator.pop() &#125; toNews(props) &#123; this.push(props, &#123; component: News, name: 'news' &#125;) &#125; toAbout(props) &#123; this.push(props, &#123; component: About, name: 'about' &#125;) &#125;&#125; 1234567891011121314151617181920212223242526272829303132// 不同的场景 创建不同的elementrenderScene(&#123; component, name, props, id, index &#125;, navigator) &#123; this.router = this.router || new Router(navigator) if (component) &#123; return React.createElement(component, &#123; ...props, ref: view =&gt; this[index] = view, router: this.router, route: &#123; name, id, index &#125; &#125;) &#125;&#125;render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;StatusBar backgroundColor=&#123;config.theme_color&#125; barStyle=\"light-content\" /&gt; &lt;Navigator ref=&#123;view =&gt; this.navigator=view&#125; initialRoute=&#123;initialRoute&#125; configureScene=&#123;this.configureScene.bind(this)&#125; renderScene=&#123;this.renderScene.bind(this)&#125;/&gt; &lt;Utils/&gt; &lt;/View&gt; )&#125; 八、AsyncStorage 数据存储解决了场景切换，数据缓存也是之前webapp开发的痛点， 主要的原因是localstorage的容量不一致，而且用户也可以直接清除浏览器缓存。 AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的。它用来代替LocalStorage， 使用方式非常简单： 1234567891011121314151617mport React, &#123; AsyncStorage&#125; from 'react-native'export async function setItem (key, value) &#123; if (value == null) return Promise.reject('StorageService Error: value should not be null or undefined') return await AsyncStorage.setItem(key, JSON.stringify(value))&#125;export function getItem (key) &#123; return AsyncStorage.getItem(key) .then(function (value) &#123; return JSON.parse(value) &#125;)&#125; async await 是es7的新特性，用于定义一个异步的函数 九、Animated 动画处理 动画是现代用户体验中非常重要的一个部分，Animated 库就是用来创造流畅、强大、并且易于构建和维护的动画。最简单的工作流程就是创建一个 Animated.Value ，把它绑定到组件的一个或多个样式属性上。然后可以通过动画驱动它，譬如 Animated.timing ，或者通过 Animated.event 把它关联到一个手势上，譬如拖动或者滑动操作。除了样式，Animated.value 还可以绑定到props上，并且一样可以被插值。这里有一个简单的例子，一个容器视图会在加载的时候淡入显示 12345678910111213141516171819202122class FadeInView extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; fadeAnim: new Animated.Value(0), // init opacity 0 &#125;; &#125; componentDidMount() &#123; Animated.timing( // Uses easing functions this.state.fadeAnim, // The value to drive &#123;toValue: 1&#125;, // Configuration ).start(); // Don't forget start! &#125; render() &#123; return ( &lt;Animated.View // Special animatable View style=&#123;&#123;opacity: this.state.fadeAnim&#125;&#125;&gt; // Binds &#123;this.props.children&#125; &lt;/Animated.View&gt; ); &#125; &#125; 以上的代码和介绍来源于 官方文档 ， 动画目前还不是特别熟悉，但是使用之后还是非常流畅的。 最后总的来说，react-native 开发出来的app 还是非常流畅的，现场它的生态也非常好，一些ui库和原生模块很快就能找到。上个月阿里也发布了原生方案 weex ，就目前来说生态还是不太好，不能直接在项目上使用。 我们需要开发双端一致的app时， react-native就成了不二之选。","tags":[{"name":"移动端","slug":"移动端","permalink":"http://myronliu.com/tags/移动端/"},{"name":"react-native","slug":"react-native","permalink":"http://myronliu.com/tags/react-native/"}]},{"title":"html5网络连接","date":"2016-05-31T04:05:05.000Z","path":"2016/05/31/html5/html5网络连接/","text":"XMLHttpRequest Level 2XMLHttpRequest Level 2 对于 老版本的XMLHttpRequest对象 功能的一个补全，这里我们先看下老版本的XMLHttpRequest对象的缺点 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提示有没有完成。 受到”同域限制”（Same Origin Policy），只能向同一域名的服务器请求数据 而新版的 XMLHttpRequest 增加了更多的功能 可以设置HTTP请求的时限。 可以使用FormData对象管理表单数据。 可以上传文件。 可以请求不同域名下的数据（跨域请求）。 可以获取服务器端的二进制数据。 可以获得数据传输的进度信息。 设置请求时限1234 xhr.timeout = 3000;xhr.ontimeout = function(event)&#123; alert('请求超时！'); &#125; 目前，Opera、Firefox和IE 10支持该属性，IE 8和IE 9的这个属性属于XDomainRequest对象，而Chrome和Safari还不支持。 FormData 上传文件1234567891011121314&lt;input type=\"file\" accept=\"video/*\" onchange=\"fileUpload(this.files[0])\"/&gt;&lt;script type=\"text/javascript\"&gt; function fileUpload(file)&#123; var xhr = new XMLHttpRequest(); var formData = new FormData(); formData.append(\"glbh\", params.key); formData.append(\"fileName\", file.name); //文件大小 formData.append(\"fileSize\", file.size); formData.append(\"file\", file); xhr.open('post', '/uploadFile'); xhr.send(formData); &#125;&lt;/script&gt; 更多的事件监听12345678910xhr.addEventListener('progress', function(oEvent)&#123; //监听上传进度&#125; , false);xhr.addEventListener('load', function(evt)&#123; //上传完成&#125;, false);xhr.addEventListener('error', function(e)&#123; //上传出错&#125;, false); WebSocketHTTP协议是一种无状态协议，服务器端本身不具有识别客户端的能力，必须借助外部机制，比如session和cookie，才能与特定客户端保持对话。这多多少少带来一些不便，尤其在服务器端与客户端需要持续交换数据的场合（比如网络聊天），更是如此。为了解决这个问题，HTML5提出了浏览器的WebSocket API。 WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的通信。举例来说，HTTP协议有点像发电子邮件，发出后必须等待对方回信；WebSocket则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。 建立连接1234567var connection = new WebSocket('ws://localhost:1740'); //建立连接connection.onopen = function(event)&#123; //连接建立成功后调用此方法&#125;connection.onclose = function()&#123; //连接被关闭调用此方法&#125; WebSocket协议完全可以取代Ajax方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。 WebSocket不使用HTTP协议，而是使用自己的协议。 发送和接收数据12345connection.send(message); //发送文字信息// 使用Blob发送文件var file = document.querySelector('input[type=\"file\"]').files[0];connection.send(file); 客户端收到服务器发送的数据，会触发message事件。可以通过定义message事件的回调函数，来处理服务端返回的数据。 123connection.onmessage = function (event) &#123; console.log(event.data);&#125; 上面代码的回调函数的参数为事件对象event，该对象的data属性包含了服务器返回的数据。 Socket.ioSocket.io是目前最流行的WebSocket实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。 1234567var socket = io.connect('http://localhost');//监听事件socket.on('news', function (data)&#123; console.log(data);&#125;);//发送信息socket.emit('anotherNews'); 上面代码的io.sockets.on方法指定connection事件（WebSocket连接建立）的回调函数。在回调函数中，用emit方法向客户端发送数据，触发客户端的news事件。然后，再用on方法指定服务器端anotherNews事件的回调函数。 不管是服务器还是客户端，socket.io提供两个核心方法：emit方法用于发送消息，on方法用于监听对方发送的消息。 Server-Sent Events传统的网页都是浏览器向服务器“查询”数据，但是很多场合，最有效的方式是服务器向浏览器“发送”数据。比如，每当收到新的电子邮件，服务器就向浏览器发送一个“通知”，这要比浏览器按时向服务器查询（polling）更有效率。 服务器发送事件（Server-Sent Events，简称SSE）就是为了解决这个问题，而提出的一种新API，部署在EventSource对象上。目前，除了IE，其他主流浏览器都支持。 简单说，所谓SSE，就是浏览器向服务器发送一个HTTP请求，然后服务器不断单向地向浏览器推送“信息”（message）。这种信息在格式上很简单，就是“信息”加上前缀“data: ”，然后以“\\n\\n”结尾。 SSE与WebSocket有相似功能，都是用来建立浏览器与服务器之间的通信渠道。两者的区别在于： WebSocket是全双工通道，可以双向通信，功能更强；SSE是单向通道，只能服务器向浏览器端发送。WebSocket是一个新的协议，需要服务器端支持；SSE则是部署在HTTP协议之上的，现有的服务器软件都支持。SSE是一个轻量级协议，相对简单；WebSocket是一种较重的协议，相对复杂。SSE默认支持断线重连，WebSocket则需要额外部署。SSE支持自定义发送的数据类型。 123456789101112131415161718var source = new EventSource('/dates');source.onmessage = function(e)&#123; console.log(e.data);&#125;;// 或者source.addEventListener('message', function(e)&#123;&#125;)source.onopen = function(event) &#123; // handle open event&#125;;// 或者source.addEventListener(\"open\", function(event) &#123; // handle open event&#125;, false); SSE 有两个事件， open用代开连接后事件， message，当接收到信息后的事件， 其中message的event对象有以下属性 data：服务器端传回的数据（文本格式）。origin： 服务器端URL的域名部分，即协议、域名和端口。lastEventId：数据的编号，由服务器端发送。如果没有编号，这个属性为空。 fetchJavaScript 通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说它很有用，但它不是最佳API。它在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近JavaScript流行的Promise以及基于生成器的异步编程模型不太搭. fetch 是w3c新推出用于 http协议数据交互的api， 主要是问了解决上述中 XMLHttpRequest 对象的缺点。 fetch基于 promise 的异步设计，是http请求操作更为优雅。 123456789101112fetch(\"/data.json\").then(function(res) &#123; // res instanceof Response == true. if (res.ok) &#123; res.json().then(function(data) &#123; console.log(data.entries); &#125;); &#125; else &#123; console.log(\"Looks like the response wasn't perfect, got status\", res.status); &#125;&#125;, function(e) &#123; console.log(\"Fetch failed!\", e);&#125;); 在请求的时候也可以修改一些参数, 例如我们发送一个post请求 123456789101112131415fetch(\"http://www.example.org/submit.php\", &#123; method: \"POST\", headers: &#123; \"Content-Type\": \"application/x-www-form-urlencoded\" &#125;, body: \"firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess\"&#125;).then(function(res) &#123; if (res.ok) &#123; alert(\"Perfect! Your settings are saved.\"); &#125; else if (res.status == 401) &#123; alert(\"Oops! You are not authorized.\"); &#125;&#125;, function(e) &#123; alert(\"Error submitting form!\");&#125;); 无论Request还是Response都可能带着body。由于body可以是各种类型，比较复杂，所以前面我们故意先略过它，在这里单独拿出来讲解。 body可以是以下任何一种类型的实例： ArrayBufferArrayBufferView (Uint8Array and friends)Blob / File字符串URLSearchParamsFormData ——目前不被Gecko和Blink支持，Firefox预计在版本39和Fetch的其他部分一起推出。 此外，Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象。 arrayBuffer()blob()json()text()formData() 在使用非文本的数据方面，Fetch API和XHR相比提供了极大的便利。 Navigation Timing在页面开发中我们需要对网页中一些操作的性能做监测，以便于后续的顶点优化，例如： 资源文件下载时间，dom渲染时间等等,HTML5 给我们提供了 Navigation Timing API 来处理这些问题， 该API通过window.performance对象的属性来报告页面被导航或被加载的时间及相关信息。 navigation:用户是怎样导航到当前页面的。timing:页面被导航或被加载完毕时所耗费的时间。 在Chrome浏览器中，从任何页面上执行以下操作： 从浏览器右上角的图标菜单中选择“工具”&gt;“JavaScript控制台”。 在JavaScript控制台底部的&gt;提示符旁边输入“performance”命令后按回车键。 点击“performance”查看memory对象、navigation对象及timing对象的各属性值。 点击timing对象旁的箭头查看它的属性值。 你会看到这样一些信息: 123456789101112131415161718192021connectEnd: 1351215923674connectStart: 1351215923667domComplete: 1351215925257domContentLoadedEventEnd: 1351215925095domContentLoadedEventStart: 1351215925091domInteractive: 1351215925091domLoading: 1351215924954domainLookupEnd: 1351215923667domainLookupStart: 1351215923667fetchStart: 1351215923667loadEventEnd: 0loadEventStart: 1351215925257navigationStart: 1351215923667redirectEnd: 0redirectStart: 0requestStart: 1351215923675responseEnd: 1351215925024responseStart: 1351215924948secureConnectionStart: 0unloadEventEnd: 1351215924949unloadEventStart: 1351215924949 Navigation Timing 将页面各个操作的时间点都记录了下来，我们只需将这些数据传输到后台，进过后台的分析来判断哪些部分页面耗时过长需要优化。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://myronliu.com/tags/HTML5/"}]},{"title":"html5设备api","date":"2016-05-31T01:00:02.000Z","path":"2016/05/31/html5/html5设备api/","text":"为了更好地为移动设备服务，HTML 5推出了一系列针对移动设备的API。 ViewportViewport指的是网页的显示区域，也就是不借助滚动条的情况下，用户可以看到的部分网页大小，中文译为“视口”。正常情况下，viewport和浏览器的显示窗口是一样大小的。但是，在移动设备上，两者可能不是一样大小。 一般来说viewport的大小要比浏览器可视区域要大，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。 我们在开发移动端页面的时候都会去设置viewport宽度 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui\"&gt; 上面代码指定，viewport的缩放规则是，缩放到当前设备的屏幕宽度（device-width），初始缩放比例（initial-scale）为1倍，禁止用户缩放（user-scalable）。 width viewport的宽度 initial-scale 初始化缩放比例 minimum-scale 最小缩放比例 maxinum-scale 最大缩放比例 user-scalable 用户是否可以缩放 minimal-ui ios7以上隐藏浏览器导航栏 Geolocation APIGeolocation接口用于获取用户的地理位置。它使用的方法基于GPS或者其他机制（比如IP地址、Wifi热点、手机基站等）。 getCurrentPosition方法，用来获取用户的地理位置。使用它需要得到用户的授权，浏览器会跳出一个对话框，询问用户是否许可当前页面获取他的地理位置。必须考虑两种情况的回调函数：一种是同意授权，另一种是拒绝授权。如果用户拒绝授权，会抛出一个错误。 12345navigator.geolocation.getCurrentPosition(function(event)&#123; console.log(event.coords.latitude + ', ' + event.coords.longitude);&#125;, function(event)&#123; console.log(\"Error code \" + event.code + \". \" + event.message);&#125;); 成功后的函数的参数是一个event对象。event有两个属性：timestamp和coords。timestamp属性是一个时间戳，返回获得位置信息的具体时间。coords属性指向一个对象，包含了用户的位置信息，主要是以下几个值： coords.latitude：纬度coords.longitude：经度coords.accuracy：精度coords.altitude：海拔coords.altitudeAccuracy：海拔精度（单位：米）coords.heading：以360度表示的方向coords.speed：每秒的速度（单位：米） Vibration APIVibration接口用于在浏览器中发出命令，使得设备振动。显然，这个API主要针对手机，适用场合是向用户发出提示或警告，游戏中尤其会大量使用。由于振动操作很耗电，在低电量时最好取消该操作。 123navigator.vibrate(1000); //震动 1snavigator.vibrate([500, 300, 100]); //震动 500ms 等待 300ms 再震动 100ms OrientationOrientation API用于检测手机的摆放方向（竖放或横放）。 一旦设备的方向发生变化，会触发deviceorientation事件，可以对该事件指定回调函数。 12345window.addEventListener(\"deviceorientation\", function(event)&#123; console.log(event.alpha); console.log(event.beta); console.log(event.gamma);&#125;); 上面代码中，event事件对象有alpha、beta和gamma三个属性，它们分别对应手机摆放的三维倾角变化。要理解它们，就要理解手机的方向模型。当手机水平摆放时，使用三个轴标示它的空间位置：x轴代表横轴、y轴代表竖轴、z轴代表垂直轴。event对象的三个属性就对应这三根轴的旋转角度。 alpha：表示围绕z轴的旋转，从0到360度。当设备水平摆放时，顶部指向地球的北极，alpha此时为0。beta：表示围绕x轴的旋转，从-180度到180度。当设备水平摆放时，beta此时为0。gramma：表示围绕y轴的选择，从-90到90度。当设备水平摆放时，gramma此时为0。 DeviceMotionEventDeviceMotionEvent 用于检测设备加速度，例如， 摇一摇，重力感应等等, 下面这段代码用于监控手机晃动 12345678910111213141516171819202122232425262728var SHAKE_THRESHOLD = 3000;var last_update = 0;var x = y = z = last_x = last_y = last_z = 0;function init() &#123; if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion', deviceMotionHandler, false); &#125; else &#123; alert('not support mobile event'); &#125;&#125;function deviceMotionHandler(eventData) &#123; var acceleration = eventData.accelerationIncludingGravity; var curTime = new Date().getTime(); if ((curTime - last_update) &gt; 100) &#123; var diffTime = curTime - last_update; last_update = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z; var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; if (speed &gt; SHAKE_THRESHOLD) &#123; alert(\"摇动了\"); &#125; last_x = x; last_y = y; last_z = z; &#125;&#125; 上面代码通过判断两次手机移动的距离和时间，来判断手机手否晃动。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://myronliu.com/tags/HTML5/"}]},{"title":"html5离线存储","date":"2016-05-30T11:37:49.000Z","path":"2016/05/30/html5/html5离线存储/","text":"HTML5 提供了强大的本地化功能，使 web 应用在离线或者网络情况较差的环境下依然能正常访问，HTML5 的本地化功能主要分为 OFFLINE (离线) 和 STORAGE （存储）。 STORAGE（存储）Cookie在HTML5以前我们会使用 cookie，在浏览器端缓存一些数据，例如：登录用户信息，历史搜索信息等等。但是cookie所支持的容量仅仅只有 4k ，也没有专门的api来操作，只能依赖一些开源的库， 这里使用 cookies.js 存储和获取cookie信息 1234567891011121314151617// 这是一个cookie值Cookies.set('key', 'value');// 链式调用Cookies.set('key', 'value').set('hello', 'world');// 可以额外设置一些参数Cookies.set('key', 'value', &#123; domain: 'www.example.com', secure: true &#125;);// 设置缓存时间Cookies.set('key', 'value', &#123; expires: 600 &#125;); // Expires in 10 minutesCookies.set('key', 'value', &#123; expires: '01/01/2012' &#125;);Cookies.set('key', 'value', &#123; expires: new Date(2012, 0, 1) &#125;);Cookies.set('key', 'value', &#123; expires: Infinity &#125;);// 获取Cookies.get('key'); 由此可见用cookie存储有一下几个缺点: 存储数据的量比较小 本身没有方便的api对其进行操作 cookie信息会在http请求时加入到请求头中，既不安全也增加了带宽。 WEB StorageHTML5 提拱更好的本地存储规范 localStorage 和 sessionStorage , 它们将数据存储在本地，而且在http请求时不会携带 Storage 里的信息, 使用方式也很简单: 1234567localStorage.setItem('key', 'value');localStorage.getItem('key');localStorage.removeItem('key');sessionStorage.setItem('key', 'value');sessionStorage.getItem('key');sessionStorage.removeItem('key'); sessionStorage 和 localStorage 使用方式及特性基本一致，唯一的区别是， sessionStorage 只在会话内有效，当浏览器窗口关闭，sessionStorage 缓存的数据会自动被清除， 而 localStorage 只要不手动清除，它会永久保存在本地。 这里有张图片分析了 cookie 、 localStorage 、 sessionStorage 三者的区别 OFFLINE（离线）为了让 webapp 拥有像 native app 一样的功能和体验， 在 HTML5的规范中加入了许多新的api， 让页面可以在离线环境下正常访问。 service worker 和 indexedDB 两者配合可以就可以开发离线使用的 webapp 了，由于 service worker 目前的兼容性不太好，这里我们写介绍下比较早的方案 application cache 。 service workerService Worker是基于Web Worker的事件驱动的，他们执行的机制都是新开一个线程去处理一些额外的，以前不能直接处理的任务。对于Web Worker，我们可以使用它来进行复杂的计算，因为它并不阻塞浏览器主线程的渲染。而Service Worker，我们可以用它来进行本地缓存，相当于一个本地的proxy。说起缓存，我们会想起我们常用的一些缓存技术来缓存我们的静态资源，但是老的方式是不支持调试的，灵活性不高。使用Service Worker来进行缓存，我们可以用javascript代码来拦截浏览器的http请求，并设置缓存的文件，直接返回，不经过web服务器，然后，做更多你想做的事情。 因此，我们可以开发基于浏览器的离线应用。这使得我们的web应用减少对网络的依赖。例如，我们开发了一个新闻阅读的web应用，当你用手机浏览器在有网络的情况下打开时，你可以正常的获取新闻内容。可是，如果手机进入飞行模式，那这个应用你就没法使用了。 如果我们使用了Service Worker做缓存，浏览器http请求会先经过Service Worker，通过url mapping去匹配，如果匹配到了，则使用缓存数据，如果匹配失败，则继续执行你指定的动作。一般情况下，匹配失败则让页面显示“网页无法打开”。 service work 生命周期 service work demo12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script&gt; navigator.serviceWorker.register(\"/service-worker.js\").then(function(serviceWorker) &#123; console.log(\"success!\"); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 在页面注册service-worker成功时就会调用这个js 12345678910111213141516171819202122232425262728293031323334353637this.oninstall = function(e) &#123; var resources = new Cache(); var visited = new Cache(); // Fetch them. e.waitUntil(resources.add( \"/index.html\", \"/fallback.html\", \"/css/base.css\", \"/js/app.js\", \"/img/logo.png\" ).then(function() &#123; // Add caches to the global caches. return Promise.all([ caches.set(\"v1\", resources), caches.set(\"visited\", visited) ]); &#125;));&#125;;this.onfetch = function(e) &#123; e.respondWith( // Check to see if request is found in cache caches.match(e.request).catch(function() &#123; // It's not? Prime the cache and return the response. return caches.get(\"visited\").then(function(visited) &#123; return fetch(e.request).then(function(response) &#123; visited.put(e.request, response); // Don't bother waiting, respond already. return response; &#125;); &#125;); &#125;).catch(function() &#123; // Connection is down? Simply fallback to a pre-cached page. return caches.match(\"/fallback.html\"); &#125;); );&#125;; service worker 采用事件监听机制， 上面的代码监听了 install 和 fetch 事件，当 server worker 安装成功后，调用此方法，然后缓存页面的资源文件， fetch 页面请求事件， server worker 拦截到用户请求，当发现请求文件命中缓存则从缓存中取得文件，返回给页面，无需经过服务器，借此达到离线的目的。 当然 service worker 的功能远不止现在这些， 更多api，请看这里 indexedDBindexedDB 是一个用于本地存储数据的 nosql 数据库，拥有极快的数据查询速度，而且可以直接保存js 对象。相比web sql(sqlite)更加高效，包括索引、事务处理和健壮的查询功能。indexedDB特点： 1.一个网站可能有一个或多个 IndexedDB 数据库，每个数据库必须具有惟一的名称。2.一个数据库可包含一个或多个对象存储 一个对象存储（由一个名称惟一标识）是一个记录集合。每个记录有一个键 和一个值。该值是一个对象，可拥有一个或多个属性。键可能基于某个键生成器，从一个键路径衍生出来，或者是显式设置。一个键生成器自动生成惟一的连续正整数。键路径定义了键值的路径。它可以是单个 JavaScript 标识符或多个由句点分隔的标识符。 基本使用方式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var openRequest = indexedDB.open(\"auto_people\", 3);var db; //数据库对象openRequest.onupgradeneeded = function(e)&#123; console.log(\"Running onupgradeeded...\"); var thisDB = e.target.result; if(!thisDB.objectStoreNames.contains(\"people\"))&#123; thisDB.createObjectStore(\"people\", &#123;autoIncrement:true&#125;); //新建一个store并设置主键自增长 &#125;&#125;//创建成功openRequest.onsuccess = function(e)&#123; console.log(\"success!\"); db = e.target.result; //Listen for add clicks&#125;openRequest.onerror = function(e)&#123; console.log(\"error!\"); console.dir(e);&#125;//这应该站在别的地方处理，这是做一个代码展示var transaction = db.transaction(['people'], \"readwrite\"); //创建一个连接var store = transaction.objectStore(\"people\"); //获取storevar request = store.add(&#123; name: 'myron', email: 'test@qq.com', created: new Date()&#125;); //添加信息request.onerror = function(e)&#123; alert('error!'); console.dir(e);&#125; //当添加失败时调用request.onsuccess = function(e)&#123; console.log('Did it!');&#125; //添加成功时调用request = store.get(1); //获取第一条数据request.onsuccess = function(e)&#123; var result = e.target.result; console.dir(result); if(result)&#123; //拿到存储的对象 &#125;&#125; application cacheapplication cache 缓存应用文件的一种方案, 它可以本整个网页需要的资源文件（包括html）缓存在本地，当没有网络或者网络情况较差的时候，则使用本地的缓存文件来运行，使用方式也较为便利。 1. 配置manifest文件1234567891011CACHE MANIFEST//必须以这个开头 version 1.0 //最好定义版本，更新的时候只需修改版本号 CACHE: //定义需要魂村的文件 m.png test.js test.css NETWORK: //此部分下列出的文件是需要连接到服务器的白名单资源。无论用户是否处于离线状态，对这些资源的所有请求都会绕过缓存。可使用通配符。 * FALLBACK 404.html, 500.html //，用于指定无法访问资源时的后备网页。其中第一个 URI 代表资源，第二个代表后备网页。两个 URI 必须相关，并且必须与清单文件同源。可使用通配符。 2.在html中设置缓存123456789&lt;html manifest=\"test.manifest\"&gt; &lt;head&gt; &lt;title&gt;AppCache Test&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"test.css\"&gt; &lt;script src=\"test.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 3.在服务器上设置 manifest 的 MIME-TYPE1234&lt;mime-mapping&gt; &lt;extension&gt;manifest&lt;/extension&gt; &lt;mime-type&gt;text/cache-manifest&lt;/mime-type&gt; &lt;/mime-mapping&gt; application cache 虽然没有 service work 功能那么强大，但是在浏览器不支持 service work的情况下使用 application cache 也是个不错的方案。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://myronliu.com/tags/HTML5/"}]},{"title":"HTML5 语义化","date":"2016-05-29T14:31:34.000Z","path":"2016/05/29/html5/html5语义化标签/","text":"以往的开发方式1234567&lt;div class=\"\"&gt; &lt;div class=\"\"&gt; &lt;div class=\"\"&gt; ..... &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我们在使用HTML4.1或是XHTML的开发的时候，基本上每个页面上都只有 div 和 span 标签， 浏览器并不知道每一个元素属于页面的那个部分。 为什么要语义化在W3C标准中，行为、表写、结构要分离，而HTML则负责网页的结构，更为语义化的标签可以让代码的结构更为清晰 12345678910111213141516171819&lt;header&gt; &lt;nav&gt; &lt;/nav&gt;&lt;/header&gt;&lt;section&gt; &lt;article class=\"\"&gt; &lt;header&gt; &lt;/header&gt; &lt;section&gt; &lt;/section&gt; &lt;footer&gt; &lt;/footer&gt; &lt;/article&gt;&lt;/section&gt;&lt;footer&gt;&lt;/footer&gt; 这样写出的代码可以一眼看出每一块代表的什么意思，当然语义化的好处还不只这些 1.有利于SEO优化页面上元素更为清晰，当小蜘蛛（搜索引擎爬数据的）访问页面的时候，可以更加快捷清楚的抓取到当前的网页的重要信息，更为语义化的代码可以是你的网站在搜索引擎中排名靠前。 2.无障碍阅读如果访客有视障，那么他只能通过屏幕阅读器来讲网页的信息读取出来播放给访客，更为语义化的代码可以让屏幕阅读器更容易理解。 3.有些设备可能性能比较荣，想pc上浏览器一样渲染页面这些设备对于css的支持比较弱，语义标记为设备提供了所需的相关信息，就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）。例如，一部手机可以选择使一段标记了标题的文字以粗体显示，而掌上电脑可能会以比较大的字体来显示，无论哪种方式一旦你对文本标记为标题，您就可以确信读取设备将根据其自身的条件来合适地显示页面。 HTML5的语义化标签HTML5新增了许多的语义化标签，像之前代码中有用到的 header footer nav等等 header用于描述定义每一块或者页面的头信息（页眉）; footer用于描述定义每一块或者页面的页脚信息； nav定义导航链接。 aside定义页面内容之外的内容,侧边栏等等. article定义文章。 section定义某个部分。 abbr定义缩写。 cite定义小段引用 dfn被定义的词汇 &lt;dfn&gt;organic food&lt;/dfn&gt;， 表明这一个关键词 code定义代码块 kbd表示提示键盘输入 samp表示计算机输出。 time&lt;time datetime=&quot;2011-11-18&quot;&gt;November 18th&lt;/time&gt; 标记一个时间，让计算机识别 mark定义有记号的文本。 wbr用于定义长单词的换行点，当一行字超出容器范围时，定义这个标签的单词会从这里折到第二行 q定义引用，会默认在前后加上引号 更加语义的表单12345&lt;input type=\"number\" name=\"name\" value=\"\"&gt; &lt;!--数字框--&gt;&lt;input type=\"email\" name=\"name\" value=\"\"&gt; &lt;!--邮件地址--&gt;&lt;input type=\"date\" name=\"name\" value=\"\"&gt; &lt;!--日期--&gt;&lt;input type=\"datetime\" name=\"name\" value=\"\"&gt; &lt;!--时间--&gt;&lt;input type=\"range\" name=\"name\" value=\"\"&gt; &lt;!--范围--&gt; 新增的表单在mobile端效果更为明显，例如 如果设置为 number 或 email 输入时会弹出相应的键盘。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://myronliu.com/tags/HTML5/"},{"name":"webapp","slug":"webapp","permalink":"http://myronliu.com/tags/webapp/"},{"name":"移动端","slug":"移动端","permalink":"http://myronliu.com/tags/移动端/"}]},{"title":"webapp 性能优化","date":"2016-05-29T12:18:24.000Z","path":"2016/05/29/webapp/webapp_dev2/","text":"webapp 不像传统页面，它生命周期更长，在手机端上，硬件环境并没有pc上那么好。所以性能的优化尤为重要。 webapp的性能优化主要分为两个方面 网络请求优化 和 页面渲染优化 ， 我们对于性能优化主要通过这连个方面来处理。 压缩资源文件我们在使用某些框架的时候（例如：JQuery）, 会发现有两个文件 jquery.js 和 jquery.min.js， jquery.min.js 的体积会小很多，这样在请求的时候会比较快。 所以在项目中使用到的资源文件（js、css、image）在发布之前需要进行压缩处理, 这里有些在线的压缩的工具 在线压缩， 如果使用写项目管理工具， 可以考虑用 gulp 请求。 123456789101112131415161718192021var gulp = require('gulp'), uglify = require('gulp-uglify'), rename = require('gulp-rename'), sourcemaps = require('gulp-sourcemaps'), minifycss = require('gulp-minify-css');gulp.task('js', function()&#123; return gulp.src('./test.js') .pipe(sourcemaps.init()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(uglify()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('./'));&#125;);gulp.task('css', function()&#123; return gulp.src('./test.css') .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(minifycss()) .pipe(gulp.dest('/'));;&#125;); 合并请求开发过程中，维护一个很长的js或是css文件是一个很困难的事情，常常会吧它分为很多的小得js和css文件，但是如果按照传统的方式写script/link 标签加载，会多很多请求，有http 1请求的原因，每个请求都会有一个rtt（请求回路）时间，一旦请求数量增多，那么请求的时间也会变长。 在发布之前我们可以使用一些工具将这些资源文件合并为一个, 我们常使用gulp 1234567891011121314151617181920212223242526var gulp = require('gulp'), uglify = require('gulp-uglify'), rename = require('gulp-rename'), concat = require('gulp-concat'), sourcemaps = require('gulp-sourcemaps'), minifycss = require('gulp-minify-css');gulp.task('js', function()&#123; return gulp.src('./app/**/**.js') //app 下所有的js 文件 .pipe(sourcemaps.init()) .pipe(concat('./app.js')) //合并所有文件 .pipe(gulp.dest('./')) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(uglify()) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('./'));&#125;);gulp.task('css', function()&#123; return gulp.src('./app/**/*.css') .pipe(concat('./app.css')) //app 下所有的 css文件 .pipe(gule.dest('./')) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(minifycss()) .pipe(gulp.dest('/'));;&#125;); cdn 和 gzipCDN 的全称是 Content Delivery Network ，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 GZIP 最早由 Jean-loup Gailly 和 Mark Adler 创建，用于UNⅨ系统的文件压缩。我们在Linux中经常会用到后缀为.gz的文件，它们就是GZIP格式的。现今已经成为Internet 上使用非常普遍的一种数据压缩格式，或者说一种文件格式。HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来.一般对纯文本内容可压缩到原大小的40%.这样传输就快了，效果就是你点击网址后会很快的显示出来.当然这也会增加服务器的负载. 一般服务器中都安装有这个功能模块的。 我们可以将静态的资源发布到cdn上，并开启 gzip 会大大的提高页面加载数据 lazyLoadwebapp 首屏加载速度是一个重要的指标，那么怎么让我们首页最快速度加载出来呢？首页中我们能直接看到的只有一屏，那么剩下的我们可以做 lazyload， 先加加载能直接看到，让后异步延迟加载剩下的内容。 数据缓存webapp 中有很多和后台的交互，首页加载的时候可以先使用上次的缓存数据，等请求成功后再刷新这部分的显示， 在一些短暂时间的重复请求，可以使用 sessionStorage 缓存这些数据， 使用 一些手段 设置缓存时间，短暂时间的内的重复请求就可以直接从缓存中获取数据了。 12345678910111213141516171819202122//封装请求方法function getData(url, params, onloadSuccess)&#123; var key = url; //使用 url + params 做key for(var str in params)&#123; key += str += params[str]; &#125; if(sessionStorage.getItem(key))&#123; //如果有缓存直接从缓存中取 onloadSuccess(JSON.stringify(sessionStorage.getItem(key))); reutrn ; &#125; $.ajax(&#123; url: url, data: data, dataType: 'json', type: 'post', success: function(data)&#123; sessionStorage.setItem(key, data); //缓存数据 onloadSuccess(data); &#125; &#125;);&#125; css动画GPU加速消除闪屏12345678910111213141516.animate&#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); -webkit-backface-visibility: hidden; -moz-backface-visibility: hidden; -ms-backface-visibility: hidden; backface-visibility: hidden; -webkit-perspective: 1000; -moz-perspective: 1000; -ms-perspective: 1000; perspective: 1000;&#125; js动画有些动画需要一些js控制无法使用css动画的情况，我们可以考虑使用js动画来做。可以使用window.requestAnimationFrame. window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数，以满足开发者操作动画的需求。这个方法接收一个函数作为参数，改函数在重绘前调用。 它稳定性比 setTimeout 要好，但是并不是所有的浏览器都支持这个api， 我们需要一个兼容性代码处理。 12345678910window.requestAnimationFrame = (function() &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) &#123; return window.setTimeout(callback, 1000 / 60); &#125;;&#125;)(); 布局优化PC 上有很多用float来做的布局，float的布局在需要更大的计算量，在页面渲染的时候严重影响到了加载速度，尽量考虑用 inline 和 inline-block 替代, flex box 是专为响应式设计布局方式，在移动端兼容性良好，可以考虑大范围使用，这里推荐下阮一峰大大的教程 Flex 布局教程：语法篇 优化页面上的dom数量在mobile端，如果页面中的dom数量过多，在页面滚动的时候会出现卡顿，闪烁等等不良的情况，所以我们要删除一些页面上不必要的dom元素或者将一些dom元素作为延迟加载。 优化dom查询性能先看一下这个部分的代码 123for(var i = 0; i&lt; 100; i++)&#123; var a = $('.test');&#125; 上面的代码每次循环的时候都会去进行一次dom查询，显然是不必要的消耗，我们需要在dom查询之前缓存，避免不必要的dom操作。 1234var a = $('.test');for(var i = 0; i&lt; 100; i++)&#123; // do somethings&#125;","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://myronliu.com/tags/HTML5/"},{"name":"webapp","slug":"webapp","permalink":"http://myronliu.com/tags/webapp/"},{"name":"移动端","slug":"移动端","permalink":"http://myronliu.com/tags/移动端/"}]},{"title":"最简单的webapp开发","date":"2016-05-18T00:20:24.000Z","path":"2016/05/18/webapp/webapp_dev1/","text":"之前我又想写过关于 移动端页面开发，这篇则整理一下webapp开发需要的一些最简单的条件，以最简单的方式开发一个webapp； 基础dom操作库首先对于页面上的交互还是以dom操作为主，虽说现在javascript的dom api已经很好用了，但是对于用惯jquery的人来说还是很不方便，所以我选择 zepto，它的api和jquery完全一致，但是更为轻量。 路由处理再手机端上页面切换会出现白屏，也无法做转场动画，为了坚决这些问题，我们需要开发一个单页面应用程序（ SPA ），通过解析url #后面的路径（#后面路径转换不会产生页面条件）加载不同的dom，这里也可以加上转场的动画，以获取和原生一样的用户体验。 director.js 是最纯粹的路由注册/解析器，它在不刷新页面的情况下，利用“#”符号组织不同的URL路径，并根据不同的URL路径来匹配不同的回调方法。director.js不仅可以应用在客户端，在使用node.js的后台，它也能够实现前面说的后端路由功能。 缓存移动端的网络需要考虑流量的消耗，不必要的重复请求是很粗糙的，所以很移动端需要大量使用缓存，来获取更好的用户体验。html5提供了webstorage机制储存数据，需要加一些简单的封装就可以使用了 js缓存封装 123localStorage.setItem(key, value);localStorage.getItem(key);localStorage.removeItem(key); 手势事件移动端需要监测用户不同的手势来做相应的处理，例如：微信上列表上长按显示操作菜单，滑动返回。。。。，我们可以通过监测touch事件来判断用户的手势，touch事件有以下几种： touchstart 手指接触屏幕事件touchmove 手指再屏幕上移动事件touchend 手指离开屏幕事件touchcancel 非正常离开屏幕事件（例如在触摸时，别的应用打开，或者程序意外退出。。。） 简单的手势用以上几种事件配合就可以处理了，如果手势相对复杂，可以使用 touch.js, 百度开发的手势事件库，api相当简单 1234touch.on('.target', 'swipeleft swiperight', function(ev)&#123; console.log(\"you have done\", ev.type);&#125;); 滚动条再android4.0以前手机上是不支持div滚动条的，很多的应用都引进了 iscoll.js，用js模拟滚动条，再4.0 以后有了div滚动条，可以使用原生滚动。但是在长列表渲染时，div滚动条会有闪白的情况，于是，大家就都使用，iscoll和div滚动切换的方式，再较低版本例如android 4.4之前用iscoll 4.4以上用原生滚动条。 下拉刷新和infinite-scroll下拉刷新和无限滚动式手机端的必不可少的功能，js需要监听滚动和touch事件来实现这两个功能; jQuery模拟原生态App上拉刷新下拉加载效果代码 现有框架解决方案app.jsApp.js 的目标是为移动webapp提供一个健壮良好的开端，处理常见的功能并且兼容其他流行的JS库。提供良好的路由控制，有controller的mvc设计，也可以良好的兼容其它的框架，缺点是组件相对较少，但是对于简单的webapp还是没有问题的 framework7Framework7 是一个开源免费的框架可以用来开发混合移动应用（原生和HTML混合）或者开发 iOS &amp; Android 风格的WEB APP。也可以用来作为原型开发工具，可以迅速创建一个应用的原型。 framework7 组件丰富而且可以在android和ios两种风格建切换 打包webapp需要调用原生方法，例如摄像头，通知等等，还需要将webapp打包成真正的apk或者app。这些需要通过一些工具完成; Phonegapphonegap 是一个跨平台的移动app开发框架，可以把html css js写的页面打包成跨平台的可以安装的移动app，并且可以调用原生的几乎所有的功能，比如摄像头，联系人，加速度等。 HBuilderHBuilder 是国产的混合是开发解决方案，包括有HBuilder编辑器 H5+规范调用原生api， mui框架，native.js与原生通信，它提供云打包以json格式配置app，再性能不错，经自己的比较再同样的程序的性能用Hbuilder更加。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://myronliu.com/tags/HTML5/"},{"name":"webapp","slug":"webapp","permalink":"http://myronliu.com/tags/webapp/"},{"name":"移动端","slug":"移动端","permalink":"http://myronliu.com/tags/移动端/"}]},{"title":"关于webapp开发——移动端页面","date":"2016-05-14T12:24:39.000Z","path":"2016/05/14/webapp/webapp_mobile_page/","text":"去年的时候有写过一篇关于移动web开发的文章，经过一年的webapp开发，对于移动端页面的开发又有了一个新的看法。总结一下怎么做好一个webapp，首先我们从移动端页面开始吧。 viewport简单来说viewport就是浏览器用来显示网页的部分(也可能是一个app中的webview)，但是viewport的大小并不局限于浏览器可视区域，一般来说viewport的大小要比浏览器可视区域要大，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。 meta设置既然浏览器是用过 viewport 展示网页，所以我们要让手机端的网页不用通过缩放的方式来浏览，我们把viewport的大小设置同浏览器可是区域一样，并且禁止缩放网页。这些再 head 中加入 meta 设置完成。 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui\"&gt; width viewport的宽度 initial-scale 初始化缩放比例 minimum-scale 最小缩放比例 maxinum-scale 最大缩放比例 user-scalable 用户是否可以缩放 minimal-ui ios7以上隐藏浏览器导航栏 css reset犹豫浏览器对内置标签的css默认属性不同，css reset就是为了统一不同浏览器的标签默认样式，这里我们就重复造轮子了，使用normalize.css, 另外不同元素的宽度计算不一样，需要加上这段代码 12345*,*:before,*:after&#123; box-sizing: border-box;&#125; 关于单位 px em 和 rem我们的页面会在不同尺寸的设备上运行，当我们需要把整体字体大小加大时，一个一个修改的方法实在太笨了。所以在响应式页面中需要使用em或是rem作为单位,下面简单解释下em，和rem。 em和rem都是相对单位，像是这样 12345678html&#123; font-size: 10px;&#125;body&#123; font-size: 14px; font-size: 1.4em; font-size: 1.4rem;&#125; 唯一不同时em是相对于父元素的大小，rem是相对于根元素(html元素) 关闭点击高亮浏览器中默认可以的点击元素在点击之后都未有高亮显示，但是由于手机端会有300ms的点击延迟，所以最好关闭这种高亮，然后自己添加样式控制 123&#123;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);&#125; 禁止选取文本和文本溢出处理123456789.no-select&#123; user-select: none; -webkit-user-select: none;&#125;.ellipsis&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; ios回弹滚动和去除输入框阴影123456789.scroll&#123; overflow: auto; -webkit-overflow-scrolling: touch;&#125;input,textarea &#123; border: 0; /* 方法1 */ -webkit-appearance: none; /* 方法2 */&#125; 监测键盘弹出事件1234567891011121314151617181920var timer, windowInnerHeight;function eventCheck(e) &#123; if (e) &#123; //blur,focus事件触发的 $('#dv').html('android键盘' + (e.type == 'focus' ? '弹出' : '隐藏') + '--通过' + e.type + '事件'); if (e.type == 'click') &#123;//如果是点击事件启动计时器监控是否点击了键盘上的隐藏键盘按钮，没有点击这个按钮的事件可用，keydown中也获取不到keyCode值 setTimeout(function () &#123;//由于键盘弹出是有动画效果的，要获取完全弹出的窗口高度，使用了计时器 windowInnerHeight = window.innerHeight;//获取弹出android软键盘后的窗口高度 timer = setInterval(function () &#123; eventCheck() &#125;, 100); &#125;, 500); &#125; else clearInterval(timer); &#125; else &#123; //计时器执行的，需要判断窗口可视高度，如果改变说明android键盘隐藏了 if (window.innerHeight &gt; windowInnerHeight) &#123; clearInterval(timer); $('#dv').html('android键盘隐藏--通过点击键盘隐藏按钮'); &#125; &#125; &#125; $('#txt').click(eventCheck).blur(eventCheck); click 300ms延迟移动设备为了监听双击缩放viewport事件，再touchend之后要等待300ms来判断是否双击在处罚事件。fastclick 就是为了解决这个问题而生的，它会再touchend之后手动触发click事件，然后阻止原来的click事件。 1FastClick.attach( document.body ); css动画 GPU加速设置3d相关属性开区GPU加速 123456.animate&#123;-webkit-transform: translate3d(0, 0, 0);-moz-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0);&#125; 消除动画闪屏1234567891011.animate&#123;-webkit-backface-visibility: hidden;-moz-backface-visibility: hidden;-ms-backface-visibility: hidden;backface-visibility: hidden;-webkit-perspective: 1000;-moz-perspective: 1000;-ms-perspective: 1000;perspective: 1000;&#125; 设备检测最后，在某些特殊的情况，我们需要针对不同浏览器做特殊处理。 123456789101112131415161718192021222324252627// 这段代码引用自：https://github.com/binnng/device.jsvar WIN = window;var LOC = WIN[\"location\"];var NA = WIN.navigator;var UA = NA.userAgent.toLowerCase();function test(needle) &#123; return needle.test(UA);&#125;var IsTouch = \"ontouchend\" in WIN;var IsAndroid = test(/android|htc/) || /linux/i.test(NA.platform + \"\");var IsIPad = !IsAndroid &amp;&amp; test(/ipad/);var IsIPhone = !IsAndroid &amp;&amp; test(/ipod|iphone/);var IsIOS = IsIPad || IsIPhone;var IsWinPhone = test(/windows phone/);var IsWebapp = !!NA[\"standalone\"];var IsXiaoMi = IsAndroid &amp;&amp; test(/mi\\s+/);var IsUC = test(/ucbrowser/);var IsWeixin = test(/micromessenger/);var IsBaiduBrowser = test(/baidubrowser/);var IsChrome = !!WIN[\"chrome\"];var IsBaiduBox = test(/baiduboxapp/);var IsPC = !IsAndroid &amp;&amp; !IsIOS &amp;&amp; !IsWinPhone;var IsHTC = IsAndroid &amp;&amp; test(/htc\\s+/);var IsBaiduWallet = test(/baiduwallet/);","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://myronliu.com/tags/HTML5/"},{"name":"webapp","slug":"webapp","permalink":"http://myronliu.com/tags/webapp/"},{"name":"移动端","slug":"移动端","permalink":"http://myronliu.com/tags/移动端/"}]},{"title":"js缓存封装","date":"2016-05-01T14:44:56.000Z","path":"2016/05/01/js缓存封装/","text":"最近写了许多webapp应用，webapp与传统网页最大的不同在于对于缓存的处理，我们手机端的网络环境较差，如果合理使用缓存可以减少网络请求，加快页面载入速度。 web storageweb storage 是html5 api中的重要特性，用于缓存数据，与传统的cookie缓存优势明显： 容量较大，每个浏览器不同理论值在 4M 以上 不会再请求时来回传输。 有现成的操作API（setItem/getItem …）,不用自己封装处理 web storage 目前ie8以上浏览器都提供支持；主要分为 localStorage 和 sessionStorage sessionStorage 缓存在回话中，当浏览器关闭，则缓存失效; localStorage 缓存在本地，只要没有被清除，则一直生效; webstorage 的api setItem (key, value) 缓存数据 key value 格式 getItem (key) 获取缓存数据 removeItem (key) 删除缓存数据 webstorage 虽然好用，但是仍然不能满足我们现在的需求，主要体现如下： api过于简单， 需要扩展一些更全面的api 无法缓存Object, 犹豫是以文本方式缓存所以只能处理字符串 无法设置缓存时长，例如我只想缓存某个数据10分钟 接下来就是对于 webstorage 的扩展封装 缓存object问题处理之前说过，webstorage是以文本方式缓存数据，所以我们先要把Object 序列化问字符串， 这自然就想到了 JSON 12345678910111213141516//这里都用localStorage做示例var store = &#123;&#125;; //封装成store对象操作store.set = function(key, value)&#123; var item = &#123; data: value &#125;; localStorage.setItem(key, JSON.stringify(item));&#125;store.get = function(key)&#123; var item = localStorage.getItem(key); if(!item) return null; item = JSON.parse(item); return item;&#125; 不是 Object 类型的数据不需要序列化，为了统一处理，所以我们创建一个新的object包装数据，提供一致的序列化处理； 缓存时长的处理webstorage 并不能像cookie一样设置缓存事件，所以我们需要自己一些手段hack; 步骤如下： 用当前事件 + 设置的缓存时长 得到 缓存数据的最后有效时间; 在包装对象中加入 end 属性为缓存最后的有效时间； 获取缓存数据时根据当前时间和缓存最后有效时间比较，如果过期则删除缓存返回null; 123456789101112131415161718store.set = function(key, value, time)&#123; var item = &#123; data: value, end: new Date().getTime() + time &#125;; localStorage.setItem(key, JSON.stringify(item));&#125;store.get = function(key)&#123; var item = localStorage.getItem(key); if(!item) return null; item = JSON.parse(item); if(new Date().getTime() &gt; item.end)&#123; item = null; localStorage.removeItem(key); &#125; return item;&#125; 更多的api直接上代码 123456789101112131415161718192021222324//获取缓存长度storage.size = function()&#123; return localStorage.length;&#125;//遍历缓存storage.each = function(func)&#123; for(var key in localStorage)&#123; if(func(store.get(key), key) === false) return; &#125;&#125;//多个数据同时缓存storage.setAll = function(obj)&#123; for(var key in obj)&#123; storage.set(key, obj[key]) &#125;)&#125;//清除所有的k缓存storage.clear = function()&#123; storage.each(function(item, key)&#123; localStorage.removeItem(key) &#125;)&#125;//...... 剩下的根据自己的需要补全就好 一个相对完善的缓存代码封装就完成。还是比较容易的，敢于尝试，编码就越来越开心。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"},{"name":"缓存","slug":"缓存","permalink":"http://myronliu.com/tags/缓存/"},{"name":"web storage","slug":"web-storage","permalink":"http://myronliu.com/tags/web-storage/"}]},{"title":"atom这个IDE有点酷","date":"2016-04-09T13:49:46.000Z","path":"2016/04/09/前端工具/atom这个IDE有点酷/","text":"最近老在各大社区上看到讨论atom编辑器，自己就去down下来试了，一下，觉得还真不错，这几天把一些配置和插件包都搞好了，正式从sublime转向atom了，这篇博客就重点介绍一下atom的使用和一些基本的插件和主题. atom是由github团队基于web开发的，由coffee和less编写，所它的插件也是以 web技术编写，并且自定义less文件修改样式，以后我觉得需要哪些功能大可以自己开发一个插件，这个是我转向atom的一个重大原因,好了不扯淡了，开始介绍atom的基本使用了。 sublime的无缝过渡atom本身就拥有了sublime的几个重要的功能， 例如： Goto Anything 、Goto Symbol、Goto Line、命令面板等等，就连快捷键也是一模一样的！所以对于用惯了sublime的同学，切换到atom是不会觉得不适应的。 啥？没有用过 sublime, 那你自己补补这边文档吧： 官方手册：Atom 基础使用 atom编辑器上用快捷键 cmd+, (我的是mac， window上用ctrl+,)，可以看到这个页面 左边这个菜单我简单介绍下 setting 一些核心的设置，什么tabsize， 文件编码， 行高字体等等。。根据自己的喜好去设置就好啦 keybinds 快捷键的设置页面，如果需要修改一些快捷键，改这里就好啦 packages 这里是你所有的安装的插件， 你可以进行卸载和设置为不可用的操作，或者 插件本生功能的设置 themes 所有安装的主题 updates 如果插件或者主题有新的版本了，就会出现在这里 install 这里用来安装atom的插件或者主题，类似于sublime的package control 插件和主题的安装atom 的插件和主题的安装都在刚才介绍的 install菜单,我们搜索插件或是主题的名称，点击安装就可以了，这里我介绍一些基础的主题和插件 setui这个是去年最流行的主题，暗黑酷炫流 atom 的主题安装和sublime 一样，需要对页面主题和编辑区域两个都做安装， 所以我们需要安装 seti-synax 和 set-ui 安装成功后去 Themes 里设置一下即可 atom还支持自定义 less文件改变样式，有兴趣的朋友可以去研究下 代码开发需要的插件 atom-beautify 可以格式化几乎所有语言的代码，比较适合从别处粘贴代码后进行格式化，或者平时不太注意代码样式的人使用。快捷键（ctrl+alt+B） linter Linter 是一个代码纠错的基础设施，安装了 Linter 后你就可以去安装具体语言的纠错插件，为你的代码提供实时的语法检查和风格检查，针对不同语言还要安装一些 插件，例如 lint-eslint， linter-csslint autocomplete-paths 自动补全文件路径 highlight-selected 当你选择了一个单词，这个插件会在编辑器中高亮显示所有这个单词出现的地方（就像你进行搜索时一样），在修改代码时非常有用。 todo-show 该插件会帮你找到代码中所有出现 TODO, FIXME 等标记的地方显示成一个表格，供你逐个解决。(社区推荐，但是我还没用过这个) docblockr 方法上生成注释 输入 /** 之后 敲enter即可生成注释模板 editorconfig 保证不同ide之间的而编码风格一致 file-type-icons 根据文件类型显示一些icons 很美观 web开发插件 atom-ternjs ternjs 是一个非常专业的 JavaScript 静态分析器，基于对代码的静态分析，可以在编码的时候给出对象的属性、函数的参数的提示。还可以基于静态分析查找标识符的定义、搜索标识符的引用、重命名标识符。该插件的正常工作需要设置一些配置项，详见其主页。 javascript-snippets js的推提示 jQuery jquery的提示插件 linter-eslint 配合eslint代码检查 linter-csslint css代码检查插件 pretty-json json格式化/压缩插件 版本控制 git git-plus 可以直接在 Atom 的命令面板中运行 git commit, git push 等常用命令，可以使用 Atom 来编辑 Commit Message, 查看 Diff, 查看文件历史等。有了这个插件就不需要离开 Atom 去 Shell 或者 GUI 来操作 Git 了。 git操作我都是再命令行中完成的，这里就不多做介绍啦 最后atom再界面上要比sublime要精美一些，我看中的是它是基于web开的，提供的高度的自定制功能，也标志着软件ui web化已经是越来越平常了，WEB前端工程师都要向客户端工程师开发，我们的考虑的不在是一个页面，而是一个应用,任重而道远啊,最后，atom也开源了基于web开发客户端程序的技术electron,我最近也在使用这个配合vue.js开发一个自己用的app.","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://myronliu.com/tags/前端工具/"},{"name":"atom","slug":"atom","permalink":"http://myronliu.com/tags/atom/"}]},{"title":"editorconfig和Eslint规范代码编辑","date":"2016-04-05T11:00:00.000Z","path":"2016/04/05/editorconfig和Eslint规范代码编辑/","text":"代码规范是一个老生常谈的问题了，在很多人维护一个项目的时候，如何保证每个人的代码风格基本一致呢，每个团队的都会给程序员制定一套开发规范，但是如何去再编写的时候能检测代码时候按照规范编写的呢，这里就需要借助前端工具 editorconfig 和 eslint 了。 editorconfigEditorConfig 可以帮助开发者在不同的编辑器和IDE之间定义和维护一致的代码风格。EditorConfig 包含一个用于定义代码格式的文件和一批编辑器插件，这些插件可以让编辑器读取配置文件并依此格式化代码。 EditorConfig 的配置文件十分易读，并且可以很好的在VCS（Version Control System）下工作。123456789101112131415root = true[*]charset = utf-8end_of_line = lfindent_size = 4indent_style = spaceinsert_final_newline = truetrim_trailing_whitespace = true[*.md]trim_trailing_whitespace = false[*.py]indent_size = 4 root 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件 [] 配置文件格式 charset 字符编码 end_of_line 定义换行符，支持lf、cr和crlf(统计不同系统下的换行符) indent_size 代码缩进size indent_style 代码缩进方式 space / tab insert_final_newline 在文件最后一行插入空行 trim_trailing_whitespace 删除多余的空格 使用 editorcofig 首先你要安装一个你的编辑的 插件 (如果是sublime直接在 package control 里搜索 editorcofig 就可以了） 然后在项目文件夹下面新建一个 .editorcofig 的文件，把上面的配置copy进去（可以根据自己的需要改改）； editorcofig 主要是做文件方面的规范，保证多个系统和ide上的一致的代码风格 eslintJavaScript是一门「年轻的语言」，因此也就存在很多糟粕的地方，这些糟粕使得程序员在编写JavaScript代码的时候，容易出错，而不易被编辑器或程序员本身发现。于是有个大牛开发了 jshint 的工具来检查js代码是否规范，但是，javascript发展太快了，各种各样的写法铺面而来，另一位大牛意识到要对不同的写法开发一套自己的linter规则（插件式开发）,于是就有的现在的 eslint ESLint 主要有以下特点：默认规则包含所有 JSLint、JSHint 中存在的规则，易迁移；规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用；包含代码风格检测的规则（可以丢掉 JSCS 了）；支持插件扩展、自定义规则。 安装方法1.安装node(现在所有的工具都是基于node，不会node都不好意思说自己是前端) 2.全局安装 eslint 和 babel-eslint12npm install -g eslintnpm install -g babel-eslint 3.属于你编辑器的eslint插件— 我用的sublime, 只需要安装 SublimeLinter 和 SublimeLinter-csslint 就好啦 配置​* ESLint主要有两种配置方法 1）Configuration Comment： 通过在所有的JS文件的JavaScript 注释中写ESLint配置信息。 2）Configuration Files: 通过一份配置文件，来对ESLint进行基本配置，配置文件可以是JavaScript、JSON、YAML中任意一种格式。如果是用过.eslintrc 或者在package.son 文件中的eslintConfig属性内进行配置，那么ESLint就能够自动的检测到这两个文件中的配置信息，如果是其他文件或文件名，就需要在命令行中指定特定的配置文件。 ESLint配置的主要内容1）Environments： 定义我们脚本的运行环境，配置这项的一个主要原因就是不同的运行环境都会有预先定义的不同的global variables。 2）Globals：配置脚本运行过程中附件的全局变量（global variables）； 3）Rules： 在我们的项目中，需要配置的代码规则，并且指定每一条规则的警告级别（error level）。比如说no-var: 2 这条规则，ESLint在进行代码检测时，如果我们JavaScript代码中使用了var申明变量，那么就会报错，其中2 是一个警告等级，在后面会介绍到。 这里是我的配置，有问题的可以查看这份 中文文档123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258&#123; \"env\": &#123; \"browser\": true, \"node\": true, \"commonjs\": true &#125;, \"ecmaFeatures\": &#123; // lambda表达式 \"arrowFunctions\": true, // 解构赋值 \"destructuring\": true, // class \"classes\": true, // http://es6.ruanyifeng.com/#docs/function#函数参数的默认值 \"defaultParams\": true, // 块级作用域，允许使用let const \"blockBindings\": true, // 允许使用模块，模块内默认严格模式 \"modules\": true, // 允许字面量定义对象时，用表达式做属性名 // http://es6.ruanyifeng.com/#docs/object#属性名表达式 \"objectLiteralComputedProperties\": true, // 允许对象字面量方法名简写 /*var o = &#123; method() &#123; return \"Hello!\"; &#125; &#125;; 等同于 var o = &#123; method: function() &#123; return \"Hello!\"; &#125; &#125;; */ \"objectLiteralShorthandMethods\": true, /* 对象字面量属性名简写 var foo = 'bar'; var baz = &#123;foo&#125;; baz // &#123;foo: \"bar\"&#125; // 等同于 var baz = &#123;foo: foo&#125;; */ \"objectLiteralShorthandProperties\": true, // http://es6.ruanyifeng.com/#docs/function#rest参数 \"restParams\": true, // http://es6.ruanyifeng.com/#docs/function#扩展运算符 \"spread\": true, // http://es6.ruanyifeng.com/#docs/iterator#for---of循环 \"forOf\": true, // http://es6.ruanyifeng.com/#docs/generator \"generators\": true, // http://es6.ruanyifeng.com/#docs/string#模板字符串 \"templateStrings\": true, \"superInFunctions\": true, // http://es6.ruanyifeng.com/#docs/object#对象的扩展运算符 \"experimentalObjectRestSpread\": true &#125;, \"rules\": &#123; // 定义对象的set存取器属性时，强制定义get \"accessor-pairs\": 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 \"array-bracket-spacing\": [2, \"never\"], // 在块级作用域外访问块内定义的变量是否报错提示 \"block-scoped-var\": 0, // if while function 后面的&#123;必须与if在同一行，java风格。 \"brace-style\": [2, \"1tbs\", &#123; \"allowSingleLine\": true &#125;], // 双峰驼命名格式 \"camelcase\": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 \"comma-dangle\": [2, \"never\"], // 控制逗号前后的空格 \"comma-spacing\": [2, &#123; \"before\": false, \"after\": true &#125;], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style \"comma-style\": [2, \"last\"], // 圈复杂度 \"complexity\": [2, 9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always \"computed-property-spacing\": [2,\"never\"], // 强制方法必须返回值，TypeScript强类型，不配置 \"consistent-return\": 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,\"that\"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 \"consistent-this\": 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 \"constructor-super\": 0, // if else while for do后面的代码块是否需要&#123; &#125;包围，参数： // multi 只有块中有多行语句时才需要&#123; &#125;包围 // multi-line 只有块中有多行语句时才需要&#123; &#125;包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要&#123; &#125;包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, \"multi\", \"consistent\"] 保持前后语句的&#123; &#125;一致 // default: [2, \"all\"] 全都需要&#123; &#125;包围 \"curly\": [2, \"all\"], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 \"default-case\": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 \"dot-location\": [2, \"property\"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;\"allowKeywords\": false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"&#125;] \"dot-notation\": [2, &#123;\"allowKeywords\": true&#125;], // 文件末尾强制换行 \"eol-last\": 2, // 使用 === 替代 == \"eqeqeq\": [2, \"allow-null\"], // 方法表达式是否需要命名 \"func-names\": 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, \"declaration\"] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, \"expression\"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, \"declaration\", &#123; \"allowArrowFunctions\": true &#125;] \"func-style\": 0, \"generator-star-spacing\": [2, &#123; \"before\": true, \"after\": true &#125;], \"guard-for-in\": 0, \"handle-callback-err\": [2, \"^(err|error)$\" ], \"indent\": [2, 2, &#123; \"SwitchCase\": 1 &#125;], \"key-spacing\": [2, &#123; \"beforeColon\": false, \"afterColon\": true &#125;], \"linebreak-style\": 0, \"lines-around-comment\": 0, \"max-nested-callbacks\": 0, \"new-cap\": [2, &#123; \"newIsCap\": true, \"capIsNew\": false &#125;], \"new-parens\": 2, \"newline-after-var\": 0, \"no-alert\": 0, \"no-array-constructor\": 2, \"no-caller\": 2, \"no-catch-shadow\": 0, \"no-cond-assign\": 2, \"no-console\": 0, \"no-constant-condition\": 0, \"no-continue\": 0, \"no-control-regex\": 2, \"no-debugger\": 2, \"no-delete-var\": 2, \"no-div-regex\": 0, \"no-dupe-args\": 2, \"no-dupe-keys\": 2, \"no-duplicate-case\": 2, \"no-else-return\": 0, \"no-empty\": 0, \"no-empty-character-class\": 2, \"no-empty-label\": 2, \"no-eq-null\": 0, \"no-eval\": 2, \"no-ex-assign\": 2, \"no-extend-native\": 2, \"no-extra-bind\": 2, \"no-extra-boolean-cast\": 2, \"no-extra-parens\": 0, \"no-extra-semi\": 0, \"no-fallthrough\": 2, \"no-floating-decimal\": 2, \"no-func-assign\": 2, \"no-implied-eval\": 2, \"no-inline-comments\": 0, \"no-inner-declarations\": [2, \"functions\"], \"no-invalid-regexp\": 2, \"no-irregular-whitespace\": 2, \"no-iterator\": 2, \"no-label-var\": 2, \"no-labels\": 2, \"no-lone-blocks\": 2, \"no-lonely-if\": 0, \"no-loop-func\": 0, \"no-mixed-requires\": 0, \"no-mixed-spaces-and-tabs\": 2, \"no-multi-spaces\": 2, \"no-multi-str\": 2, \"no-multiple-empty-lines\": [2, &#123; \"max\": 1 &#125;], \"no-native-reassign\": 2, \"no-negated-in-lhs\": 2, \"no-nested-ternary\": 0, \"no-new\": 2, \"no-new-func\": 0, \"no-new-object\": 2, \"no-new-require\": 2, \"no-new-wrappers\": 2, \"no-obj-calls\": 2, \"no-octal\": 2, \"no-octal-escape\": 2, \"no-param-reassign\": 0, \"no-path-concat\": 0, \"no-process-env\": 0, \"no-process-exit\": 0, \"no-proto\": 0, \"no-redeclare\": 2, \"no-regex-spaces\": 2, \"no-restricted-modules\": 0, \"no-return-assign\": 2, \"no-script-url\": 0, \"no-self-compare\": 2, \"no-sequences\": 2, \"no-shadow\": 0, \"no-shadow-restricted-names\": 2, \"no-spaced-func\": 2, \"no-sparse-arrays\": 2, \"no-sync\": 0, \"no-ternary\": 0, \"no-this-before-super\": 2, \"no-throw-literal\": 2, \"no-trailing-spaces\": 2, \"no-undef\": 2, \"no-undef-init\": 2, \"no-undefined\": 0, \"no-underscore-dangle\": 0, \"no-unexpected-multiline\": 2, \"no-unneeded-ternary\": 2, \"no-unreachable\": 2, \"no-unused-expressions\": 0, \"no-unused-vars\": [2, &#123; \"vars\": \"all\", \"args\": \"none\" &#125;], \"no-use-before-define\": 0, \"no-var\": 0, \"no-void\": 0, \"no-warning-comments\": 0, \"no-with\": 2, \"object-curly-spacing\": 0, \"object-shorthand\": 0, \"one-var\": [2, &#123; \"initialized\": \"never\" &#125;], \"operator-assignment\": 0, \"operator-linebreak\": [2, \"after\", &#123; \"overrides\": &#123; \"?\": \"before\", \":\": \"before\" &#125; &#125;], \"padded-blocks\": 0, \"prefer-const\": 0, \"quote-props\": 0, \"quotes\": [2, \"single\", \"avoid-escape\"], \"radix\": 2, \"semi\": [2, \"never\"], \"semi-spacing\": 0, \"sort-vars\": 0, \"space-after-keywords\": [2, \"always\"], \"space-before-blocks\": [2, \"always\"], \"space-before-function-paren\": [2, \"always\"], \"space-in-parens\": [2, \"never\"], \"space-infix-ops\": 2, \"space-return-throw-case\": 2, \"space-unary-ops\": [2, &#123; \"words\": true, \"nonwords\": false &#125;], \"spaced-comment\": [2, \"always\", &#123; \"markers\": [\"global\", \"globals\", \"eslint\", \"eslint-disable\", \"*package\", \"!\"] &#125;], \"strict\": 0, \"use-isnan\": 2, \"valid-jsdoc\": 0, \"valid-typeof\": 2, \"vars-on-top\": 0, \"wrap-iife\": [2, \"any\"], \"wrap-regex\": 0, \"yoda\": [2, \"never\"] &#125;&#125;","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://myronliu.com/tags/前端工具/"},{"name":"eslint","slug":"eslint","permalink":"http://myronliu.com/tags/eslint/"},{"name":"editorconfig","slug":"editorconfig","permalink":"http://myronliu.com/tags/editorconfig/"}]},{"title":"javascript作用域与闭包","date":"2016-03-30T04:24:00.000Z","path":"2016/03/30/javscript/javascript作用域和闭包/","text":"作用域在编程语言中，作用域控制着变量的与参数的可见性和生命周期。在javascript中并不像其他编程语言一样拥有块级作用域，在if中定义的变量再外面也可以直接调用,这点是值得注意的;12345var a= 1;if(true)&#123; var a = 2;&#125;console.log(a); //2 在块中定义的变量，再外边也可以直接调用到，也可以覆盖该作用域内同名的变量; javascript中最外层是再window(浏览器环境中)下的全局作用域；每个函数内部都会产生一个函数作用域，我们在访问一个变量的时候，会本着就近原则，从所在的函数作用域逐层向上查找，如果没有找到，就会抛出undefined异常123456789var a = 'window';function test()&#123; var a = 'func'; console.log('this test a:' +a);&#125;test();console.log('this window a:' + a);// this test a:func// this test a:window 关于变量提升123456789var a = 'window'；function test()&#123; console.log('this test a:' +a); var a = 'func';&#125;test();console.log('this window a:' + a);// this test a:undefined// this test a:window 很奇怪吧，再方法中输出a的时候，应该是全局变量中的a变量才对,javascript执行函数式，会先创建变量，然后执行语句赋值，所以在执行 console.log 之前已经定义了变量 a 但是并未赋值，这个时候 a=undefined,然后执行 console.log自然就输出undefined； 闭包作用域的好处是内部函数可以访问和定义他们的外部函数的参数和变量，而函数外部是无法直接访问无法直接访问到函数内部的变量的。那么我们怎么访问到函数内部的变量呢, 通常在函数内部再创建一个函数，再返回这个函数再外部调用;123456789function f1()&#123; var test = '这是个私有变量'; function f2()&#123; console.log(test); &#125; return f2;&#125;var result = f1();result(); // “这是个私有变量”= 这里的f2就是闭包，我对闭包的定义呢，闭包就是能够读取到函数内部变量的函数； 在上面的代码中我们看到使用闭包可以访问都函数内部的变量，再实际运用中闭包还有一个好处就是可以使得函数内部变量常驻在内存中;1234567891011function f1()&#123; var count = 1; return function ()&#123; return count++; &#125;&#125;var count = f1();console.log(count()); //1console.log(count()); //2console.log(count()); //3console.log(count()); //4 我们在封装一些类库的时候，需要有一些私有变量不给外部直接调用，这个时候就需要使用到闭包；123456789101112131415161718//缓存信息的库var cache = function()&#123; var map = &#123;&#125;; return &#123; get : function(key)&#123; return map[key]; &#125;, set : function(key, value)&#123; map[key] = value; &#125;, remove : function(key)&#123; if(map[key]) delete map[key]; &#125; &#125;;&#125;cache.set('test', 'this is test case');cache.get('test'); //this is test casecache.remove('test'); 这里我们封装了一个简单cache对象用于缓存一些信息， 使用内部变量 map 存储，外部无法直接访问 map 变量，但是可以通过 set get remove 完成对 map 增删改查的操作; 使用闭包需要注意的： 闭包会是函数作用域中所有的变量常驻在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（ object ）使用，把闭包当作它的公用方法（ Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 12345678910function f1()&#123; var TEST = '11111'//我是一个常亮，不要改变; var nouse = 'aaa'; //这是一个没有使用到的变量再f1执行完成前要释放掉 function f2()&#123; //通过TEST做一些操作 console.log(TEST);//非要条件，不要轻易改变父函数内部变量的值； &#125; nouse = null; //要吧这些不用的释放掉 return f2;&#125; this每一个函数内部都有两个固定的变量 this 和 arguments, arguments 是调用函数是传入参数的集合; this 指向调用函数的对象12345678var test = &#123; fun : function ()&#123; console.log(this, arguments); &#125;&#125;test.fun(); // test, []test.fun(1,2); // test, [1,2]test.fun(1,2,3); // test, [1,2,3] 函数中的this 永远指向调用它的对象,如果没有指定对象调用，那么this指向全局对象1234567891011var test = &#123; fun : function (func)&#123; console.log(this === test, arguments); func(); &#125;&#125;test.fun(function ()&#123; console.log(this === window);&#125;);//true//true 上面的代码中 test 中的 fun 函数是通过 test 对象调用的，所以 fun 中的 this 指向test, 而传入到fun中的方法 func 并没有通过 对象名.方法名 调用,所以是使用的默认的全局对象（ window ）调用的 func 方法。 call、apply和bind在javascript中调用一个方法，除了常用的 对象名.方法名 的调用方式外，还可以种用 Function 对象自带的 call 和 apply 方法调用, 调用时需要指定 用哪个对象调用和传入参数12345678910111213var test = &#123; msg : 'test msg'&#125;;var msg = 'window msg';function say()&#123; console.log(this.msg);&#125;//没有指定对象 默认就是windowsay.call(); // window msgsay.call(null); // window msgsay.call(this); // window msgsay.call(test); // test msg apply 方法和 call 方法都可以动态执行this的指向对象，只是在调用上有区别 12apply(obj, [arg1, arg2, arg3]);call(obj, arg1, arg2, arg3); bind 方法在 function 定义的时候使用，给 function 指定 this 指向, 当一个函数使用 bind 方法指定了 this指向后，那么在调用的时候 call 和 apply 执行的 this 指向都将无效 12345678910var test = &#123; msg :'test msg', fun: function()&#123; console.log(this.msg); &#125;.bind(window); //强制指定 window 为 this;&#125;;var msg = 'window msg';test.fun(); // window.msgtest.fun.call(test); // window.msgtest.fun.apply(test); // window.msg bind 方法是 ES5中新增的，ie8 上不支持，我们可以自定义bind来hack 12345678if(!Function.prototype.bind)&#123; Function.prototype.bind = function(context)&#123; var _self = this; return function()&#123; return _self.apply(context, arguments) &#125;; &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"如何写一个完善的jquery ui组件","date":"2016-03-30T04:24:00.000Z","path":"2016/03/30/javscript/如何写一个完善的jquery ui组件/","text":"在日常工作中，常常会遇到下面这样的需求 我们需要对上面的tab做处理，点击相应的tab就显示相应的内容 不封装组件写法最原始的写法12345678910&lt;div class=\"tab-container\"&gt; &lt;ul class=\"nav nav-tabs\"&gt; &lt;li name=\"tab1\" class=\"active\"&gt;&lt;a href=\"javascript:;\"&gt;tab1&lt;/a&gt;&lt;/li&gt; &lt;li name=\"tab2\"&gt;&lt;a href=\"javascript:;\"&gt;tab2&lt;/a&gt;&lt;/li&gt; &lt;li name=\"tab3\"&gt;&lt;a href=\"javascript:;\"&gt;tab3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=\"tab1\"&gt;this is tab1&lt;/div&gt; &lt;div id=\"tab2\" style=\"display: none;\"&gt;this is tab2&lt;/div&gt; &lt;div id=\"tab3\" style=\"display: none;\"&gt;this is tab3&lt;/div&gt;&lt;/div&gt; 12345678910111213141516$(function() &#123; $('.tab-container').on('click', 'li', function() &#123; var tabIds = ['tab1', 'tab2', 'tab3']; var id = $(this).attr('name'); //便利所有的tabid，判断是当前点击的id 就显示，否则隐藏 $.each(tabIds, function(i, el) &#123; if (id === el) &#123; $('.tab-container li[name=' + el + ']').addClass('active'); $('#' + el).show(); &#125; else &#123; $('.tab-container li[name=' + el + ']').removeClass('active'); $('#' + el).hide(); &#125; &#125;); &#125;);&#125;); 通过 li 标签的事件绑定，每次都便利所有的tab，显示点击的，隐藏其他的，这种做法可以实现 tab 切换的问题但是还有几个缺点。 无法重用，当另一个地方需要使用到时只能把代码copy过去 一个页面多次使用会有问题, 所有的选择器都是在全局上查找，当一个页面有两个或者三个tabs的时候会有bug 每一次执行显示的时候对其他的tab不管它原本的撞他，都会执行隐藏操作,这是不必要的 重用————使用jquery插件封装为了解决上面的问题，我们把这种逻辑封装成一个tabs插件, jquery对插件的支持使用 $.fn 1$.fn = jQuery.prototype; //$.fn执行jQuery对象的原型 代码如下:12345678910111213141516171819202122232425262728293031323334$.fn.tabs = function()&#123; var $element = this;//上下文 var showName = null;//当前显示tab 储存 //初始化操作 $element.find('div').hide();//现将所有隐藏掉 $element.find('.nav li').removeClass('active');//消除所有的选择状态 showName = $element.find('.nav li:eq(0)').attr('name');//初始化设置显示第一个tab //事件监听 $element.on('click', 'li', function()&#123; show($(this).attr('name')); &#125;); show(); //显示逻辑 function show(name)&#123; if(name === showName) return; if(name)&#123; //先隐藏原来的 hide(showName); showName = name; &#125; //显示当前的 $('#' + showName, $ ).show(); $('.nav li[name=' + showName + ']', $element).addClass('active'); &#125; function hide(name)&#123; //jquery方法的第二个参数表示在哪个dom搜索，默认为document $('#' + name, $element).hide(); $('.nav li[name=' + name + ']', $element).removeClass('active'); &#125;&#125;;$(function() &#123; $('.tab-container').tabs();&#125;); 这样实现之后，再别的地方需要调用只只需要调用 tabs 方法即可，但是，这种实现仍然是粗糙的。show 和 hide 方法在每次调用tabs时都会重新创建，这样比较消耗内存。 多次使用————面向对象方式处理用面向对象处理，将一些方法和属性放在原型中处理，更加高效。在编码之前，我们需要对这个组件进行分析，整个 tabs 由两个部分组成，一个导航的菜单 menu, 一个是与之对应的内容（就是下面那个div） panel, 可以把一个 menu 和 panel 组成一个对象 tab , 而 tab 有两个方法 show 和 hide 控制它的显示和隐藏，而我们的 tabs 就是 tab 对象的集合，控制着每一个tab的显示和隐藏. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Tabs($element)&#123; //初始化每一个tab对象 this.tabs = &#123;&#125;;//储存tab var self = this; $('div', $element).hide();//现将所有隐藏掉 $('.nav li', $element).removeClass('active');//消除所有的选择状态 this.showName = $('.nav li:eq(0)', $element).attr('name');//初始化设置显示第一个tab $('.nav li', $element).each(function()&#123; var name = $(this).attr('name'); var $menu = $(this); var $panel = $('#' + name, $element); var tab = new Tab($menu, $panel); self.tabs[name] = tab;//缓存tab &#125;); //事件监听 $element.on('click', '.nav li', function()&#123; self.show($(this).attr('name')); &#125;); this.show();&#125;Tabs.prototype.show = function(name)&#123; if(name === this.showName) return; if(name)&#123; this.tabs[this.showName].hide();//隐藏原来的 this.showName = name; &#125; this.tabs[this.showName].show();//显示当前的&#125;;function Tab($menu, $panel)&#123; this.$menu = $menu; this.$panel = $panel;&#125;Tab.prototype.show = function()&#123; this.$menu.addClass('active'); this.$panel.show();&#125;;Tab.prototype.hide = function()&#123; this.$menu.removeClass('active'); this.$panel.hide();&#125;;$.fn.tabs = function()&#123; new Tabs(this);&#125;; 用面向对象方法编写的组件，拥有了不错的性能，而且在代码逻辑上更为清晰，理解起来比之前的写法要复杂一点。 可配置————options处理再上面的代码中我们可以看到，所有的tabs组件开始都是显示的第一个，如果，我们想在最初显示第二个或是第三个，这个组件就无法满足我们的需求，因为它还没有加入参数(options)的处理。 通常在封装时将可变，与核心逻辑无关的属性，抽取出来成为这个组件 options, 例如 tabs 组件中,它默认显示的tab页，以及选中tab时li上的样式，这些我们都可以提取出来,以保证的组件的灵活性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Tabs.defaults = &#123; showName : null, //当前显示tab名称 activeClass : 'active', //当tab被选择时的样式 menuSelector : '.nav li', //找到menu的选择器 menuAttr : 'name' //指定menu上指定属于哪个tab名称的属性&#125;; //存储组件默认的参数function Tabs($element, options)&#123; //初始化每一个tab对象 this.tabs = &#123;&#125;;//储存tab this.$element = $element; var op = this.options = $.extend(&#123;&#125;, Tabs.defaults, options);//初始化参数 var self = this; $('div', $element).hide();//现将所有隐藏掉 $(op.menuSelector, $element).removeClass(op.activeClass);//消除所有的选择状态 if(!op.showName) this.showName = $(op.menuSelector + ':eq(0)', $element).attr(op.menuAttr);//初始化设置显示第一个tab else this.showName = op.showName; var attrName = op.menuAttr; $('.nav li', $element).each(function()&#123; var name = $(this).attr(attrName); var $menu = $(this); var $panel = $('#' + name, $element); var tabOp = &#123; activeClass : op.activeClass &#125;; var tab = new Tab($menu, $panel, tabOp); self.tabs[name] = tab;//缓存tab &#125;); //事件监听 $element.on('click', op.menuSelector, function()&#123; self.show($(this).attr(attrName)); &#125;); this.show();&#125;Tabs.prototype.show = function(name)&#123; if(name === this.showName) return; if(name)&#123; this.tabs[this.showName].hide();//隐藏原来的 this.showName = name; &#125; this.tabs[this.showName].show();//显示当前的&#125;;function Tab($menu, $panel, tabOp)&#123; this.$menu = $menu; this.$panel = $panel; this.options = tabOp;&#125;Tab.prototype.show = function()&#123; this.$menu.addClass(this.options.activeClass); this.$panel.show();&#125;;Tab.prototype.hide = function()&#123; this.$menu.removeClass(this.options.activeClass); this.$panel.hide();&#125;;$.fn.tabs = function(options)&#123; new Tabs(this, options);&#125;;$(function() &#123; $('.tab-container').tabs(&#123; showName : 'tab2' &#125;);&#125;); 暴露组件内部动作————事件处理加入了参数处理之后，组件就有了不错的灵活性，但是，组件内部发生改变时，再外面无法得知，假如我们有这样一个需求,再某个 tab 显示的时候，初始化这个tab的数据，这个时候我们就需要给组件假如事件处理，当内部发生改变的时候，触发某个事件，外部可以监听事件来观察组件的变化，做相应的处理 12345678910111213Tabs.prototype.show = function(name)&#123; if(name === this.showName) return; if(name)&#123; this.tabs[this.showName].hide();//隐藏原来的 this.showName = name; &#125; this.tabs[this.showName].show();//显示当前的 this.$element.trigger('tabs.show', this.showName);//使用jQuery的事件处理机制对于组件自定义事件一般都是,组件名称.事件名称&#125;;$('.tab-container').on('tabs.show', function(e, name) &#123; alert(name);&#125;); 提供方法给外部调用很多的时候组件也会有一些方法让外部调用，已达到手动改变组件状态的效果，例如我们需要再点击一个按钮之后显示 tab2,这种时候我们需要修改定义插件那部分的代码，以暴露方法给外部调用 1234567891011121314151617$.fn.tabs = function(options)&#123; if($.type(options) === 'object')&#123; //实例化 var tabs = new Tabs(); this.data('tabs', tabs); &#125;else&#123; var tabs = this.data('tabs'); var returnVal; if(tabs[options] &amp;&amp; $.isFunction(tabs[options]))&#123; returnVal = tabs[options].call(tabs, Array.prototype.slice.call(arguments,1)); &#125; if(returnVal) return returnVal; &#125; return this;&#125;//调用方法$('.tab-container').tabs('show', 'tab3'); 到这一个完善的组件就构建完成啦，再编写组件中还有一些需要注意的: 常用的dom或是jq最好是作为组件属性缓存起来，这样可以减少dom重复查找所消耗的时间； 一个组件要有 detory 在组件移除是要释放掉内存和事件绑定; 每次组件内部状态发生改变都要触发事件，这样可以让组件更加灵活; 不要阻止组件内部元素事件冒泡 最后我自己有封装一个jquery插件来定义组件，把组件定义常用的操作例如事件、外部调用方法，等等都有封装jquery-component 用jquery-component定义组件:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576$.component('tabs', &#123; //默认参数 options: &#123; showName: null, //当前显示tab名称 activeClass: 'active', //当tab被选择时的样式 menuSelector: '.nav li', //找到menu的选择器 menuAttr: 'name' //指定menu上指定属于哪个tab名称的属性 &#125;, //实例化调用方法 init: function() &#123; //初始化每一个tab对象 this.tabs = &#123;&#125;; //储存tab var $element = this.$element; var self = this; var op = this.options; $('div', $element).hide(); //现将所有隐藏掉 $(op.menuSelector, $element).removeClass(op.activeClass); //消除所有的选择状态 if (!op.showName) this.showName = $(op.menuSelector + ':eq(0)', $element).attr(op.menuAttr); //初始化设置显示第一个tab else this.showName = op.showName; var attrName = op.menuAttr; $('.nav li', $element).each(function() &#123; var name = $(this).attr(attrName); var $menu = $(this); var $panel = $('#' + name, $element); var tabOp = &#123; activeClass: op.activeClass &#125;; var tab = new Tab($menu, $panel, tabOp); self.tabs[name] = tab; //缓存tab &#125;); //事件监听 $element.on('click', op.menuSelector, function() &#123; self.show($(this).attr(attrName)); &#125;); this.show(); &#125;, show: function(name) &#123; if (name === this.showName) return; if (name) &#123; this.tabs[this.showName].hide(); //隐藏原来的 this.showName = name; &#125; this.tabs[this.showName].show(); //显示当前的 this._trigger('show', this.showName);//对事件的封装 &#125;, destory : function()&#123; //当元素被销毁的时候回自动调用这个方法 &#125;&#125;);function Tab($menu, $panel, tabOp) &#123; this.$menu = $menu; this.$panel = $panel; this.options = tabOp;&#125;Tab.prototype.show = function() &#123; this.$menu.addClass(this.options.activeClass); this.$panel.show();&#125;;Tab.prototype.hide = function() &#123; this.$menu.removeClass(this.options.activeClass); this.$panel.hide();&#125;;$(function() &#123; $('.tab-container').tabs(&#123; showName: 'tab2' &#125;); $('.tab-container').on('tabs.show', function(e, name) &#123; alert(name); &#125;);&#125;);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://myronliu.com/tags/jquery/"}]},{"title":"javascript数据驱动页面","date":"2016-03-29T07:21:00.000Z","path":"2016/03/29/javscript/javascript数据驱动页面/","text":"2005 Ajax 提出，web2.0的时代到来，web开发开始越来越注重与用户交互，于是乎，越来越多的后端逻辑迁移到前端实现，javascript代码量大大提升，但是，大量的业务逻辑也ui逻辑混在一起，导致程序臃肿，代码难以维护。于是开始有了，一些类似 spring 的分层的思想，将业务逻辑和ui逻辑分开。 MVC( backbone ）MVC是一个架构设计模式，它通过分离关注点的方式来支持改进应用组织方式。它促成了业务数据(Model)从用户界面(View)中分离出来，还有第三个组成部分(Controller)负责管理传统意义上的业务逻辑和用户输入。 Model 数据模型一般以json对象的形式展现View表示表现层，也就是用户界面，对于网页来说，就是用户看到的网页HTML代码。Controller 表示控制层，用来对原始数据（Model）进行加工，传送到View。 mvc结构中 view是根据 模板 + 数据（Model） 生成的一段html代码，当我们的用户进行点击按钮或者输入等等操作的时候，就会产生一个动作（ action ）view会把 action 传递给controller，controller中进行逻辑处理对原始model进行修改，view监控到model的改变之后，通过模板和新的数据重新渲染页面。 在项目中往往采用更加灵活的方式，以 backbone 为例： 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。 MVP（React）MVP 是基于 MVC 模式一种演变， P代表的是 Presenter（展示器），其模式如下图所示： 我们可以看到 view和model是通过展示器做联系，当view中发生了动作（Dom事件)会先传递给展示器，由展示进行逻辑处理，改变model，同时展示其还监控了model的变化，当model发生改变的时候展示其会做相应的逻辑处理并重新渲染页面。 这种做法 View 非常薄，不部署任何业务逻辑，称为”被动视图”（ Passive View ），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 实际使用中以 react 为例:在react中 以 virtual dom 就是展示器，而组件的状态 就是model, 当页面上产生事件的时候，会先传递到 virtual dom dom触发组件中的事件，组件中进行逻辑处理，改变调用 setState 方法改变状态， 组件会重新监控状态改变，调用 render 方法产生新的 virtual dom，再通过 virtual dom 的对比，得出哪些节点发生改变，然后更新改变的节点的真实dom; MVVM( angular angular2 vue)MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）; viewModel会观察 model的变化，当model发生改变的时候，viewModel会改变绑定了这个 model 的dom，同时 viewModel也会监控view的变化，当view发生改变的时候，其绑定的model也会发生改变 angular,vue等框架都是基于mvvm模式的一种实现","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"hexo+coding搭建自己的博客","date":"2016-03-24T14:39:24.000Z","path":"2016/03/24/hexo-coding搭建自己的博客/","text":"毕业以来，尝试过用各种手段写博客，先是csdn的博客专栏谢了几篇文章之后，就懒了，只到去年，学习了markdown语法写博客，觉得非常好用，于是也开始用farbox写博客，最近接触一个hexo加上github的pages服务搭建博客，于是尝试下，犹豫github在国内的访问速度实在是不太好，我用coding代替. 准备环境1.NODE犹豫hexo是基于node开发的，所以node环境是必须的 2.gitnode的包管理都是需要使用git来down包的，我们提交文章和代码也需要用到git 3.coding账号我们需要使用到 coding 的pages服务搭建博客，如果觉得coding的逼格不够的话，可以看下这篇文章HEXO+Github,搭建属于自己的博客 安装hexoNODE 和 GIT 都安装好了之后就可以下载安装 hexo1npm install -g hexo 国内的访问外网会有点慢，最好把npm仓库源设置为淘宝镜像12npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/dist 安装完成之后新建一个文件夹，进入文件夹内执行 init 命令123mkdir blogcd bloghexo init init之后会看到文件下有了如下结构的文件 生成静态文件，本地启服务器调试上面图片中的source目录就是存在我们文章地址的地方，文章用markdown语法编写，hexo还会自动解析，并进行分类和归档；执行以下命令可以生成静态文件1hexo generate 本地启动服务器调试1hexo server 启动成功之后访问http://localhost:4000就可以看到你的主页啦，到此搭建工作就算基本完成了 部署博客到coding上再coding上新建一个仓库，保证你的项目名称和用户名（个性后缀）一致，不然加载资源文件可能会有问题 更改 _config.yml 文件中的配置,一般在最后一行1234deploy: type: git repository: https://git.coding.net/liuyy/liuyy.git branch: master 执行deploy命令1hexo deploy 如果出现报错，先检查你的配置git地址是否正确，”:”号后面一定要跟一个空格,如果都没有问题则再安装一个包，1npm install hexo-deployer-git --save 执行完成之后，去coding的项目目录项，开启pages服务,开启之后访问http://[user_name].coding.me,好了，大功告成。 关于hexo的图片处理我从farbox中把原来的文章迁移过来，发现好多的图片都显示，再hexo中你要现先设置 post_asset_folder: true 设置完成之后，每一个markdown文件都有一个相同的名称的文件夹（迁移过来的文章是没有的需要自己创建）用来存储使用到的图片，再文章中，url只用写文件名称即可1![](11-11.png) 关于markdown编辑markdown的语法，大家看这篇文档就可以了，我就不多介绍了 Markdown语法说明如果喜欢sublime编辑器的朋友我推荐使用下面两个markdown编辑的插件MarkdownEditing 它可以提供markdown文件很漂亮的语法高亮Markdown Preview markdown文件实时预览插件 最后特别鸣谢，曾老师 对我搭建博客上的帮助；","tags":[{"name":"hexo","slug":"hexo","permalink":"http://myronliu.com/tags/hexo/"}]},{"title":"javascript面向对象编程","date":"2016-03-23T11:19:00.000Z","path":"2016/03/23/javscript/javascript面向对象编程/","text":"“面向对象编程”（Object Oriented Programming，缩写为OOP）是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 对象的理解那么，什么是对象呢？我们可以从两个层次理解： （1）“对象”是单个实物的抽象。 一本书、一辆汽车、一个人都可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。当实物被抽象成“对象”，实物之间的关系就变成了“对象”之间的关系，从而就可以模拟现实情况，针对“对象”进行编程。 （2）“对象”是一个容器，封装了“属性”（property）和“方法”（method）。 所谓“属性”，就是对象的状态；所谓“方法”，就是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，“属性”记录具体是那一种动物，“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 构造函数“面向对象编程”的第一步，就是要生成“对象”。前面说过，“对象”是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后“对象”根据这个模板生成。 典型的面向对象语言（如：c#/java）,都有 类 这个概念用于构造对象， 对象就是类的实例，类就是对象的模板，但是，JavaScript语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 在ES6中也有了类的概念来构造对象 构造函数是一个正常的函数，但是它的特征和用法与普通函数不一样。下面就是一个构造函数。 1234function Person()&#123; this.name = 'myron'; this.age = 22;&#125; 可以看到，Person就是构造函数，通过this属性来封装自身的属性和方法，构造函数的特点有两个： 函数内部使用了this关键字，指向生成的对象; 必须用 new 命令调用函数生成对象； 1var myron = new Person(); 上面的代码就创建了一个新的对象，而new命令的执行过程是先创建一个空的对象，然后用这个对象去掉用构造函数完成是实例化操作，执行构造函数时会忽略到构造函数中的return语句,下面的代码来模拟new命令的执行过程; 1234567function _new(/*构造函数，实例化参数*/)&#123; var args = [].slice.call(arguments); var constructor = args.shift(); var context = Object.create(constructor.prototype);//根据原型链创建新的对象 var result = constructor.apply(context, args); //调用构造方法 return result;&#125; 原型JavaScript通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。1234567891011function Person(name, age)&#123; this.name = name; this.age = age; this.introduce = function()&#123; console.log('my name is ' + this.name + ', ' + this.age + ' years old' ); &#125;&#125;var myron = new Person('myron', 22);var ling = new Person('若绫', 20);console.log(myron.introduce === ling.introduce);//false 在上面的代码中创建了两个实例, 但是它们的 introduce 方法却不一样，也就是，我们写在构造函数中的函数和属性在每次实例化得时候都会重新创建。对于一些公用的资源（函数/属性）来说，这既没有必要，又浪费系统资源，因为这些完全可以共享。 我们创建的每个函数都有一个 prototype(原型)属性,这个属性是一个对象,它的用途是包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解: prototype 通过 调用构造函数而创建的那个对象的原型对象 。使用原型的好处可以让所有对象实例共享它所 包含的属性和方法。也就是说,不必在构造函数中定义对象信息 ,而是可以直接将这些信息 添加到原型中。12345678910function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.introduce = function()&#123; console.log('my name is ' + this.name + ', ' + this.age + ' years old' );&#125;var myron = new Person('myron', 22);var ling = new Person('若绫', 20);console.log(myron.introduce === ling.introduce);//true 为了更进一步了解构造函数的声明方式和原型模式的声明方式 ,我们通过图示来了解一下: 在原型模式声明中,多了两个属性,这两个属性都是创建对象时自动生成的。proto 属性是实例指向原型对象的一个指针,它的作用就是指向构造函数的原型属性 constructor。 通过这两个属性,就可以访问到原型里的属性和方法了。 原型模式的执行流程:1.先查找构造函数实例里的属性或方法,如果有,立刻返回;2.如果构造函数实例里没有,则去它的原型对象里找,如果有,就返回; 继承javascript没有 类 的概念，自然也没有类的继承(ES6除外),我们只能通过一些独特的方法完成继承操作. 属性拷贝这是最简单也最容易理解的继承方法，便利一个对象的所有属性，然后设置给另一个对象123456789var a = &#123; a: 'aa'&#125;var b = &#123; b: 'bb'&#125;for(var key in a)&#123; b[key] = a[key]&#125; 上述继承方式只针对Object继承，只是对单个对象有用，又有一个对象需要继承a则需要重新遍历一次,所以我们函数再构造函数上动手脚吧 构造继承再子类构造函数中用this对象调用父类构造函数方法，完成子类对父类的继承关系12345678910function Animal()&#123; this.age = 10; this.weight = '50kg';&#125;function Cat()&#123; Animal.call(this);&#125;var cat = new Cat();console.log(cat.age === 10 ? '完成继承啦' : ''); 但是这种方法，只能继承父类中构造函数定义的属性和方法，如果函数定义在原型中则无法继承; 原型继承之前就说每个函数都有prototype属性，用于共享属性和方法，但同同时它本身就是一个对象，也有自己的prototype,这样一来就形成一条原型继承链。1234567891011function Animal()&#123; this.age = 10; this.weight = '50kg';&#125;function Cat(name)&#123; this.name = name; //定义自己的属性&#125;Cat.prototype = new Animal();//继承animal属性和方法Cat.prototype.say = function()&#123; //新增一些原型属性和方法 console.log('喵~');&#125; 利用原型继承可以完成做父类所有的方法和属性的继承，也可以定义一些子类特有的属性和方法.推荐一下jQuery作者写的类工厂的实现 点这里 它通过 Class.create 方法创建类，需要继承则调用 extend 函数，另外在函数内部this._super指向父类的同名方法.1234567891011121314151617181920212223242526272829303132var Person = Class.extend(&#123; init: function(isDancing)&#123; this.dancing = isDancing; &#125;, dance: function()&#123; return this.dancing; &#125;&#125;);var Ninja = Person.extend(&#123; init: function()&#123; this._super( false ); &#125;, dance: function()&#123; // Call the inherited version of dance() return this._super(); &#125;, swingSword: function()&#123; return true; &#125;&#125;);var p = new Person(true);p.dance(); // =&gt; truevar n = new Ninja();n.dance(); // =&gt; falsen.swingSword(); // =&gt; true// Should all be truep instanceof Person &amp;&amp; p instanceof Class &amp;&amp;n instanceof Ninja &amp;&amp; n instanceof Person &amp;&amp; n instanceof Class 混合Mixin是JavaScript中用的最普遍的模式，几乎所有流行类库都会有Mixin的实现。Mixin是掺合，混合，糅合的意思，即可以就任意一个对象的全部或部分属性拷贝到另一个对象/类上。1234567891011121314151617181920212223//基本的混合实现var mixin = &#123; say : function()&#123; console.log(this.sayMsg); &#125;&#125;;function Cat(name)&#123; this.name = name; //定义自己的属性 this.sayMsg = '喵~';&#125;function Dog(name)&#123; this.name = name; this.sayMsg = '汪!汪!汪!';&#125;//把mixin加入到两个类中for(var key in mixin)&#123; Cat.prototype[key] = mixin[key]; Dog.prototype[key] = mixin[key];&#125;var cat = new Cat('小黄');var dog = new Dog('旺财');cat.say();dog.say(); 很多时候，我们只需要使用到某个类中的一个或者两个方法，来避免重复定义函数，这个时候如果用继承来实现，那么代价就太大了，而且在多次继承之后，子类方法很可能写会不经意覆盖掉了祖类（父类的父类。。。）的方法导致对象有些操作不能正常完成。 因此我们只需要两级或者三级继承，将一些公用的功能或是函数都抽出来，作为一个个独立的object，需要使用到这些，就利用混合的方法加入到类中。这种方式，可以极大的提升代码的复用性。我自己的实现：可以继承和混合的类工厂","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"javascript模块化编程(二)--commonjs,AMD,CMD","date":"2016-03-21T15:40:00.000Z","path":"2016/03/21/javscript/javascript模块化编程(二)--commonjs,AMD,CMD/","text":"前面的写法，再文件模块比较少的情况都不会有问题，但是再当模块比较多之后，window下还是会被挂载很多对象，而且当模块依赖过多的时候需要在’（）’，写很长的参数，于是乎，前端模块化，有了一些规范，让我们去定义模块。 AMDAMD是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”，它采用异步加载模块的方法，使用require的方法先加载定义上数组中的依赖模块，全部完成后执行回调函数。123require([&apos;module1&apos;], function(module1)&#123; module1.doSomethings();//调用模块方法&#125;); 采用异步加载，不会使浏览器卡死。也可以定义一个模块1define(moduleId?, [modules]?, factory); 其中 moduleId 模块Id可以忽略，忽略的时候加载使用文件路径modules 依赖模块,可以输模块id或是文件路径,没有可以忽略factory 加载完依赖之后的回调方法，这里是模块定义的具体实现，利用return语句返回模块 12345//注意依赖模块会返回对象，传入回调函数中define(&apos;render&apos;, [&apos;jQuery&apos;], function($)&#123; //do somethings return &#123;&#125;;&#125;); 关于amd规范的实现：require.js cmd规范CMD（Common Module Definition）公共模块定义规范，在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：1define(factory) define 是一个全局函数，用来定义模块。factory可以是一个JSON,字符串等等…12define(&#123;aa : \"aa\"&#125;);define('ddd'); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module：12345678define(function(require, exports, module) &#123; var module1 = require('module1'); // 正确写法 module.exports = &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); require 用于加载模块依赖；exports 导出对象，等同于module.exports;module 模块对象，用于使用module.exports导出对象; 值得注意的是exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。cmd规范实现：sea.js amd和cmd规范对比；相较于amd而言cmd的规范的优势很明显 1.按需加载, amd将依赖前置到模块定义时，也就是有些模块尚未使用到就加载了，暂用内存，不合理.2.CMD推崇依赖就近，AMD推崇依赖前置。当依赖模块过多时，回调函数如会有很长一条参数对象. commonjsCommonJs 是服务器端模块的规范，Node.js采用了这个规范。根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。12345678910var test=&quot;a&quot;;//私有变量var $ = require(&apos;jQuery&apos;);//拉取文件依赖exports.aa = function ()&#123;&#125;exports.bb = function()&#123;&#125;//也可以这么写module.exports = &#123;&#125; CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。现在利用一些前端打包工具，我们也可以是使用标准的额common.js规范编码了，browserify,webpack; umd我们编写一个模块，并不知道它要在哪种规范下使用，于是，需要一种编写方式能同事兼容Amd和CommonJs模块化实现，这就是umd1234567891011(function (window, factory) &#123; if (typeof exports === &apos;object&apos;) &#123; module.exports = factory(); &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.module1 = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;); UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。如果都不存在模块化实现那么就放在window对象下。 ES6模块化历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。 export命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。123export var name1 = &apos;Michael&apos;;export var name2 = &apos;Jackson&apos;;export var name3 = 1958; import命令使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。12//import ajax from &apos;../ajax.js&apos; export default命令1234// export-default.jsexport default function () &#123; console.log(&apos;foo&apos;);&#125; 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。123// import-default.jsimport customName from &apos;./export-default&apos;;customName(); // &apos;foo&apos; 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。Es6中已经提供了比较完善的模块化方案，但是目前兼容不太好，只能通过babel转码成es5代码再通过webpack打包.ES6模块化这部门讲的比较粗糙，如果感兴趣可以看下阮一峰大大的教程ECMAScript6入门-Module","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"javascript模块化编程(一)","date":"2016-03-21T15:30:00.000Z","path":"2016/03/21/javscript/javascript模块化编程(一)/","text":"随着web开发逐渐演变成web application之后，尤其是在web2.0依赖页面上的javascript脚本逐渐变多，嵌入网页的JavaiScript代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者需要分模块，来管理前端代码开发。 原始写法模块就是实现特定功能的一组方法。只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。1234567var state = '';function method1()&#123; //do somethings&#125;function mehtod2()&#123; //do somthings&#125; 上面吧state和方法放在一起组成一个模块，要使用的是否，直接调用方法即可。但是这种做法缺点也很明显，吧，变量和方法都放在了全局变量里，造成了全局污染，一但模块数量变多，后面相同名称方法或是变量就会覆盖之前的，产生一些奇怪的bug.为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面123456789var module1 = &#123; state : '', method1 : function()&#123; //do somethings &#125;, mehtod2 : function()&#123; //do somethings &#125;&#125; 这种写法将方法和变量都封装到了module1里，调用的时候直接 对象.方法名 就可以了1module1.mehtod1(); 但是，这样的写法会暴露所有模块成员，内部变量可以被外部改写。比如，外部的代码可以直接修改state的值。 用面向对象构造函数，封装私有对象利用构造函数的特性，封装私有对象123456789function ModuleClass()&#123; var hello = 'hello world'; this.sayHello = function()&#123; console.log(hello); &#125;;&#125;var module = new ModuleClass();module.sayHello(); 这样私有变量在外部就不会被访问到，这种把函数直接写在写在构造函数内部的做法，每次实例化的时候都会创建这个函数，非常耗费内存。利用prototype(原型)改写上面的程序如下:123456function ModuleClass()&#123; this.hello = 'hello world';&#125;ModuleClass.prototype.sayHello = function()&#123; console.log(this.hello);&#125; 改写之后，将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写。 利用立即执行函数写法写模块使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。12345678var module = (function()&#123; var hello = 'hello world'; return &#123; sayHello : function()&#123; console.log(hello); &#125; &#125;&#125;)(); 这样一来，外部就无法访问到私有的hello变量了。更多的时候我们模块需要一来另一些模块或者全局变量，返回的时候挂载再全局变量上123456789101112131415161718192021(function(window, $)&#123; var hello = 'hello world'; function f1 ()&#123; //do somethings &#125; function f2 ()&#123; //do somethings &#125; function f3 ()&#123; //do somethings &#125; //这里也可以对引入对象进行扩展 $.fn.test = function()&#123; &#125; window.module1 = &#123; sayHello : function()&#123; console.log(hello); &#125; &#125;&#125;)(window, jQuery); 如果这个模块需要让外部调用哪些方法，只用挂载到module1上就可以了,同时，立即执行函数内部也可以对引入对象（例如jQuery，做扩展操作。以保证内部的方法和变量都是独立的，不会影响到外面","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"css布局-BFC和IFC","date":"2016-03-04T04:29:00.000Z","path":"2016/03/04/css/css布局-BFC和IFC/","text":"Formatting Contexts是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFCBFC(Block Formatting Contexts)直译为”块级格式化上下文”。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素,反之也是如此。 BFC形成 float 的值不为 none position 的值不为 static 或 relative display属性为inline-boxs、table-cells、table-captions的不是块盒的块容器(除非这个值已经被传播到视口), overflow不为visible的块盒才会为它的内容创建新的BFC。 body元素 BFC渲染规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠，常用来清除浮动和布局。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 IFCIFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响) IFC渲染规则 框会从包含块的顶部开始，一个接一个地水平摆放。 摆放这些框的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。在垂直方向上，这些框可能会以不同形式来对齐：它们可能会把底部或顶部对齐，也可能把其内部的文本基线对齐。能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。水平的margin、padding、border有效，垂直无效。不能指定宽高。 行框的宽度是由包含块和存在的浮动来决定。 IFC ‘line-height’ 与 ‘vertical-align’ 属性 计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。 行内级元素根据其 ‘vertical-align’ 属性垂直对齐。在这些框使用 ‘top’ 或 ‘bottom’ 对齐的情况下，user-agent必须以最小化行框的高为目标对齐这些框。若这些框够高，则存在多个解而 CSS 2.1 不定义行框基线的位置。 行框的高是最顶端框的顶边到最底端框的底边的距离。","tags":[{"name":"css","slug":"css","permalink":"http://myronliu.com/tags/css/"}]},{"title":"css布局-盒模型，定位和浮动","date":"2016-03-04T04:27:00.000Z","path":"2016/03/04/css/css布局-盒模型，定位和浮动/","text":"盒模型简单来说，网页中的额每一个元素都是一个盒子，而整个网页就是有大大小小的盒子组装起来的。既然是盒子那么它就有：内容（content）、填充（padding）、边框（border）、边界（margin）这些属性，而每个属性又有上下左右四个方向，像下面这张图这样 display每一个元素都是一个盒子，display属性就决定了他们属于那种盒子；目前大致分为以下几种 块级元素（block）一般是其他元素的容器，可容纳内联元素和其他块状元素，块状元素排斥其他元素与其位于同一行，宽度(width)高度(height)起作用。常见块状元素为div和p。 内联元素(inline)内联元素只能容纳文本或者其他内联元素，它允许其他内联元素与其位于同一行，但宽度(width)高度(height)不起作用。常见内联元素为“a”。 内联块级元素(inline block)同时拥有块级元素和内联元素的特性 positiondisplay决定了盒子种类，position就确定了盒子的位置， （标准文档流）static常规元素默认值都是static，指按照文档至上而下的标准文档流 （绝对定位）absolute绝对定位，他默认参照已经定位(position值不为static)的元素父级元素，配合top、right、bottom、left进行定位。脱离标准文档流，也就是他的位置不会影响到其他的元素，也不会参与到父元素高度计算上，但是会受到富元素overflow:hidden的影响 （绝对定位）fixed参照window配合top、right、bottom、left进行定位。脱离标准文档流，不会受到父元素overflow:hidden影响; （相对定位）relative相对定位，他是默认参照父级的原始点为原始点，配合top、right、bottom、left进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位。 浮动（float）首先要知道，div是块级元素，在页面中独占一行，自上而下排列，那么如何让块级元素在一行中显示呢，这里就用到float;float:left/right可以让块级元素在一行中从左至右或者从右至左排列，但是，需要主要的是，当元素设置了float:left/right时，会影响到后面的元素所以需要及时的清除浮动，而且会造成父级元素高度塌陷。常用的清除浮动代码如下:1234567891011.clear &#123; clear: both; &#125;/*清除浮动*//*清除浮动并防止父级元素高度塌陷*/.clearfix:before, .clearfix:after &#123; content: '\\0020'; display: block; overflow: hidden; visibility: hidden; width: 0; height: 0; &#125;.clearfix:after &#123; clear: both &#125;.clearfix &#123; *zoom: 1 &#125;","tags":[{"name":"css","slug":"css","permalink":"http://myronliu.com/tags/css/"}]},{"title":"javascript类工厂构建","date":"2015-12-06T14:43:00.000Z","path":"2015/12/06/javscript/javascript类工厂构建/","text":"下面的代码基于javascript原型继承设计，轻量，好用。12345678910111213141516171819202122232425262728293031323334353637 var initializing = false, fnTest = /xyz/.test(function() &#123; xyz; &#125;) ? /\\b_super\\b/ : /.*/;var Class = function() &#123;&#125;;Class.extend = function(prop) &#123; var _super = this.prototype; initializing = true; var prototype = new this(); initializing = false; for (var name in prop) &#123; prototype[name] = typeof prop[name] == \"function\" &amp;&amp; typeof _super[name] == \"function\" &amp;&amp; fnTest.test(prop[name]) ? (function(name, fn) &#123; return function() &#123; var tmp = this._super; this._super = _super[name]; var ret = fn.apply(this, arguments); this._super = tmp; return ret; &#125;; &#125;)(name, prop[name]) : prop[name]; &#125; function Class() &#123; if (!initializing &amp;&amp; this.init) this.init.apply(this, arguments); &#125; Class.prototype = prototype; Class.prototype.constructor = Class; Class.extend = arguments.callee; return Class;&#125;; 使用方式123456789101112var A = Class.extend(&#123; init : function()&#123; console.log('the class'); &#125;&#125;);//B继承Avar B = A.extend(&#123; init : function()&#123; this._super(); &#125;&#125;);new B();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"前端seo优化","date":"2015-11-24T13:44:00.000Z","path":"2015/11/24/移动web/前端seo优化/","text":"123456789101112131415161718192021222324252627核心心法：让小蜘蛛最快找到有用信息1. &lt;p&gt;&lt;br/&gt;&lt;/p&gt;很赞的写法 &lt;br/&gt;写在p内部2.外链 要加上 rel=“nofollow” 避免搜索引擎爬网爬跑掉其他网页去了3.&lt;a&gt;标签加title描述4.&lt;img&gt;标签加alt描述5.标签中的内容就是内容，不要加的代码，&amp;nbsp尽量设置padding/margin/缩进来实现效果a. &lt;title&gt; 关键词放前面；不重复；每个title不同；b. &lt;meta keywords&gt; 列出关键词即可，不需太多；c. &lt;meta description&gt; 高度概括网页内容，不需太多，每个页面不同；d. 语义化代码：aa. H1-H6 用于标题；bb. UL无序列表；cc. OL有序列表；dd. DL定义数据列表ee. em,strong 强调e. 优化：aa. &lt;a&gt; title/rel/bb. &lt;h1&gt; 正文标题一定用H1，副标题H2；cc. &lt;p&gt; &lt;br&gt;是文本内的换行；dd. &lt;caption&gt;表格标题；ee. &lt;img&gt; 加alt说明；ff. &lt;strong&gt;（高度重视） &lt;em&gt; （仅次于strong）&amp; &lt;b&gt;（不推荐） &lt;i&gt;gg. 重要HTML放在最前面；hh. 重要内容不用JS输出；ii. 少使用iframe框架；JJ. 谨慎使用display:none（使用z-index）;kk. 精简代码；","tags":[]},{"title":"前端代码规范(YaHoo军规)","date":"2015-11-24T13:43:00.000Z","path":"2015/11/24/移动web/Yahoo军规/","text":"1.尽可能减少HTTP请求数（请求耗时）2.使用CDN（内容分发网络）3.添加Expire/Cache-Control头（缓存设置）4.启用Gzip压缩（压缩css和js代码，混淆js代码）5.把css放在页面最上面（方便加载渲染）6.把script放在页面最下面（防止script代码影响页面展示）7.避免在css中使用Expression8.把JavaScript和css放在外部分文件中（js和css文件浏览器是自动缓存的不会重复加载）9.减少DNS查询10.避免重定向","tags":[]},{"title":"sublime常用的插件介绍","date":"2015-11-16T00:06:00.000Z","path":"2015/11/16/前端工具/sublime常用的插件介绍/","text":"Package Control包管理器，安装这个插件之后可以管理sublime的所有的扩展包的安装和卸载安装方法如下，打开console窗口（CTRL+/views&gt;show console）将下面这段代码copy进去敲enter即可 1import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 接下来得插件安装， 打开命令面板ctrl+shift+p 输入ip,enter 输入插件名称敲击enter Emmet前身事大名鼎鼎的zen coding，仅仅需要一行代码就能快速生成html代码。简单的语法既可以生成负责html css代码(点击标题，可以学习emmet语法)， SideBar Enhancements这个插件改进了侧边栏，增加了许多功能：将文件移入回收站，在浏览器中浏览，将文件复制到剪切板。 AutoFileName文件名称自动补全插件 CSS3css3的语言环境，也会对一些css3的属性惊醒提示 DocBlockr文本注释插件，再js方法上敲击/**+ enter即可变成下面的代码12345/** * [ description] * @param &#123;[type]&#125; item [description] * @return &#123;[type]&#125; [description] */ JsFormatjavascript格式化插件，安装之后选择文本ctrl+alt+f可以格式化指定文本 SublimeCodeIntel多种语言提示，代码自动补齐，快速跳转到变量定义，在状态栏显示函数快捷信息等它支持的语言有：PHP, Python, RHTML, JavaScript, Smarty, Mason, Node.js, XBL, Tcl, HTML, HTML5, TemplateToolkit, XUL, Django, Perl, Ruby, Python3. SublimeLinter代码检查插件，可以提示你的编码错误，但是需要安装子包，例如1.javascript语法检查 SublimeLinter-jshint这个包是必须得；2.css语法检查 sublimeLinter-csslint SublimeLinter-csslint配置sublimelinter，的css语法检查插件 SublimeLinter-jshint配置sublimelinter，的js语法检查插件 TagHTML/XML 标签缩进、补全和校验； Terminal打开控制台插件，安装后配置上下面的快捷键即可1&#123; &quot;keys&quot;: [&quot;command+shift+m&quot;], &quot;command&quot;: &quot;open_terminal&quot; &#125;,` TrailingSpaces多余空格标记插件，会标记每行多余的空格，加入下边的快捷键配置即可一次删除1&#123; &quot;keys&quot;: [&quot;command+shift+t&quot;], &quot;command&quot;: &quot;delete_trailing_spaces&quot; &#125;, 主题包sublime本身的外表就已经很好看了，如果大家对颜值有特殊要求的，可以点击这里 各种framework包 jQuery jquery的代码补全包； Angular angular的代码补全及常用指令提示； less less的环境高亮 saas sass的语法环境高亮，以及代码提示….","tags":[{"name":"前端工具 sublime","slug":"前端工具-sublime","permalink":"http://myronliu.com/tags/前端工具-sublime/"}]},{"title":"javascript异步处理","date":"2015-11-14T16:26:00.000Z","path":"2015/11/15/javscript/javascript异步处理/","text":"javascript是单线程语言，所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。这种方式比较好控制，不会存在像java那个多线程死锁等等复杂的问题，缺点也很明显，当一个任务执行较长时间时，后续的任务需要等待，会拖延整个程序的执行，使浏览器卡死。为了解决这个问题，javascript将任务分为两种：同步（Synchronous）和异步（Asynchronous）;在浏览器端，如果需要执行比较耗时的任务，为了避免浏览器卡死，就需要异步执行，不影响其他任务，最常见的例子是ajax操作。但是一旦使用异步，还要保证有些任务再异步任务之后执行，这个时候就需要特殊的处理了，以下介绍四中常见的处理异步的方法 一、回调函数这个是最常见的处理方式，假设一个ajax请求，设定一个success方法再请求成功时回调12345$.ajax( url :'test', success : function(data)&#123; &#125;); 这样ajax请求不会阻塞其他程勋的正常运行回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 二、事件监听事件驱动模式。success任务在请求成功事件发生时执行。还是以ajax为例：12345678910function success()&#123; console.log('the ajax successed');&#125;$.on('success', success);//监听事件 如果发生执行success方法$.ajax( url : 'test', success : function()&#123; $.trigger('success');//出发success 事件 &#125;); 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以去耦合（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 三、发布/订阅基于观察者模式，可以用新闻的方式来理解，例：123456789$.subscribe('news', function()&#123; console.log(\"我来看新闻\");&#125;); //订阅新闻$.ajax( url : 'getNews', success : function()&#123; $.publish(\"news\");//发布新闻 &#125;); 当ajax请求完成之后会发布信号告诉所有的订阅者“我已经执行完了”，订阅者接收到后，会执行相应的操作这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 四、Promise对象Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。就像下面这样:1start().then(step1).then(step2) 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。实现代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * Promise.js * 异步处理的Promise对象 */;(function(Global, factory) &#123; if (typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\") &#123; module.export = factory(); &#125; else if (define &amp;&amp; typeof define === 'function') &#123; define(function() &#123; return factory(); &#125;); &#125; else &#123; if (!window.Promise) window.Promise = factory(); &#125;&#125;)(window, function() &#123; var Promise = function(startFunc) &#123; this.state = 'pending'; this.thenables = []; //存储接下来的步骤 if(startFunc &amp;&amp; typeof startFunc === 'function')&#123; startFunc(this.resolve, this.reject); &#125; &#125;; /** * 改变状态为已完成 * @param &#123;[type]&#125; value 传递的值 * @return &#123;[type]&#125; [description] */ Promise.prototype.resolve = function(value) &#123; if (this.state != 'pending') return; this.state = 'fulfilled'; this.value = value; this._handleThen(); return this; &#125;; /** * 改变状态为有异常 * @param &#123;[type]&#125; reason [description] * @return &#123;[type]&#125; [description] */ Promise.prototype.reject = function(reason) &#123; if (this.state != 'pending') return; this.state = 'rejected'; this.reason = reason; this._handleThen(); return this; &#125;; Promise.prototype.then = function(onFulfilled, onRejected) &#123; var thenable = &#123;&#125;; if (typeof onFulfilled == 'function') &#123; thenable.fulfill = onFulfilled; &#125; if (typeof onRejected == 'function') &#123; thenable.reject = onRejected; &#125; /** * 如果状态不是pending就立即执行 */ if (this.state != 'pending') &#123; if (setImmediate) &#123; setImmediate(function() &#123; this._handleThen(); &#125;.bind(this)); &#125; else &#123; setTimeout(function() &#123; this._handleThen(); &#125;.bind(this), 0); &#125; &#125; thenable.promise = new Promise(); this.thenables.push(thenable); return thenable.promise; &#125;; Promise.prototype._handleThen = function() &#123; if (this.state === 'pending') return; if (this.thenables.length) &#123; for (var i = 0; i &lt; this.thenables.length; i++) &#123; var thenPromise = this.thenables[i].promise; var returnedVal; try &#123; switch (this.state) &#123; case 'fulfilled': if (this.thenables[i].fulfill) &#123; returnedVal = this.thenables[i].fulfill(this.value); &#125; else &#123; thenPromise.resolve(this.value); &#125; break; case 'rejected': if (this.thenables[i].reject) &#123; returnedVal = this.thenables[i].reject(this.reason); &#125; else &#123; thenPromise.reject(this.reason); &#125; break; &#125; if (returnedVal === null) &#123; this.thenables[i].promise.resolve(returnedVal); /*判断返回值是否是Promise对象，如果值那么下个promise执行要绑定在返回值的then方法上*/ &#125; else if (returnedVal instanceof Promise || typeof returnedVal.then === 'function') &#123; returnedVal.then(thenPromise.resolve.bind(thenPromise), thenPromise.reject.bind(thenPromise)); &#125; else &#123; this.thenables[i].promise.resolve(returnedVal); &#125; &#125; catch (e) &#123; thenPromise.reject(e); &#125; &#125; this.thenables = []; &#125; &#125;; return Promise;&#125;); 需要注意的地方 异步回调函数都是在主任务执行完毕后执行,如果主任务卡死，那么回调函数将不会执行; ajax的同步方法最好不要轻易使用，程序需要等待请求成功才会继续向下执行，如果请求时间过长浏览器会卡死； 如果你想保证你的某些函数再主函数执行完后再执行可以使用setTimout(function(){}，0);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"sublime自定义代码提示","date":"2015-11-14T16:05:00.000Z","path":"2015/11/15/前端工具/sublime自定义代码提示/","text":"snippet我们在编写代码的时候老是有些代码模板重复使用，常规的做法是copy过来，这种做法几位耗时间，这个时候snippet就来了， 1.Snippe创建,存储和格式Snippet文件是以.sublime-snippet为扩展的XML文件, 可以命名为XXX.sublime-snippet, 创建自己的snippet的方式为菜单栏Tools | New Snippet..文件格式如果123456789&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[Type your snippet here]]&gt;&lt;/content&gt; &lt;!-- Optional: Tab trigger to activate the snippet --&gt; &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; &lt;!-- Optional: Scope the tab trigger will be active in --&gt; &lt;scope&gt;source.python&lt;/scope&gt; &lt;!-- Optional: Description to show in the menu --&gt; &lt;description&gt;My Fancy Snippet&lt;/description&gt;&lt;/snippet&gt; ps:存储在包目录下user目录下即可简要介绍一下snippet四个组成部分: content:其中必须包含&lt;![CDATA[…]]&gt;,否则无法工作, Type your snippet here用来写你自己的代码片段 tabTrigger:用来引发代码片段的字符或者字符串, 比如在以上例子上, 在编辑窗口输入hello然后按下tab就会在编辑器输出Type your snippet here这段代码片段 scope: 表示你的代码片段会在那种语言环境下激活, 比如上面代码定义了source.python, 意思是这段代码片段会在python语言环境下激活.（html为 text.html js为source.js） description :展示代码片段的描述, 如果不写的话, 默认使用代码片段的文件名作为描述,会在提示时显示 2. snippet环境变量列举一下可能用到的环境变量, 这些环境变量是在Sublime中已经预定义的.$TM_FILENAME 用户文件名$TM_FILEPATH 用户文件全路径$TM_FULLNAME 用户的用户名$TM_LINE_INDEX 插入多少列, 默认为0$TM_LINE_NUMBER 一个snippet插入多少行$TM_SOFT_TABS 如果设置translate_tabs_to_spaces : true 则为Yes$TM_TAB_SIZE 每个Tab包含几个空格同一通过下面的代码片段进行验证:1234567891011121314151617&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[=================================$TM_FILENAME 用户文件名$TM_FILEPATH 用户文件全路径$TM_FULLNAME 用户的用户名$TM_LINE_INDEX 插入多少列, 默认为0$TM_LINE_NUMBER 一个snippet插入多少行$TM_SOFT_TABS 如果设置translate_tabs_to_spaces : true 则为Yes$TM_TAB_SIZE 每个Tab包含几个空格=================================]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;scope&gt;source.python&lt;/scope&gt;&lt;/snippet&gt; 验证方式 : 保存自定义snippet,在python文件夹下输入hello按下tab 指定光标位置和选中值123456789&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;.]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;scope&gt;text.html&lt;/scope&gt;&lt;/snippet&gt; 完成后再html文件中敲下hello然后tab，便可以看到光标选中this的问着在此tab光标选中snippet,1、2代表了选中的顺序如果有两个$1会自动进入多点编辑模式 Completions上面的提示方法虽然好但是呢，每个提示都要建一个文件，太麻烦了，如果这是代码方法或者长单词提示这种方法就不太好了，这个时候我们可以定义completions,文件格式如下：123456789&#123; \"scope\": \"text.html - source - meta.tag, punctuation.definition.tag.begin\", \"completions\": [ &#123; \"trigger\": \"hello\", \"contents\": \"hello word\" &#125;, &#123;\"trigger\": \"this is\", \"contents\":\"this is $1\"&#125; ]&#125; 存储格式为.sublime-completions同样的是放在user目录下参数解释：scope：作用域与snippet中一致trigger: 触发词contents: 内容定义$ : 这个定义光标位置与snippet一致 总结snippet适用于大段代码提示，completions适用于小段代码提示，都非常好用，快去自定义一套适合自己打代码提示吧！ 参考链接 手把手教你写Sublime中的Snippet sublime completions sublime snippets","tags":[{"name":"前端工具 sublime","slug":"前端工具-sublime","permalink":"http://myronliu.com/tags/前端工具-sublime/"}]},{"title":"sublime功能介绍","date":"2015-11-14T10:07:00.000Z","path":"2015/11/14/前端工具/sublime功能介绍/","text":"sublime是一个小巧，功能又十分强大得文本编辑器，下面就来介绍下它的几个强大的工恩呢刚 快速文件查找sublime上 CTRL+P可以查找文件，只用输入其中几个关键字便可找到 另外输入在后面加上#可以并查找文件中的内容，确定后打开文件后跳到指定内容位置 后面加上@+方法名 可以打开文件兵跳转到指定方法行 最后输入：1334可以跳到指定行 多点编辑模式sublime中按住CRTL建然后在不同位置点击鼠标左键可进入多点编辑模式，另外CTRL+D多次使用可以选取相同字符并自动进入多点编辑模式，非常好用 命令面板假设一个场景，我想把侧边栏收起来，但是又不记得快捷键，这个时候命令面板就起作用了，打开命令面板CRTL+SHIFT+P，输入toggle side bar然后enter这样就可以了，sublime中所有的操作都可以再命令面板中找到，让大家告别无聊的鼠标 灵活的配置和自定制sublime中所有的配置都是再json文件中设置，一般有连个default和user我们如果要修改某些配置，只需要再user文件中修改，会自动覆盖default的配置，sublime有许许多多的插件，只要花点心思找些插件包，便可以配置成一个符合你习惯的完美的编辑器","tags":[{"name":"前端工具 sublime","slug":"前端工具-sublime","permalink":"http://myronliu.com/tags/前端工具-sublime/"}]},{"title":"sublime常用快捷键","date":"2015-11-14T09:32:00.000Z","path":"2015/11/14/前端工具/sublime常用快捷键/","text":"##基础快捷键Ctrl+Shift+P：打开命令面板Ctrl+P：搜索项目中的文件Ctrl+G：跳转到第几行Ctrl+W：关闭当前打开文件Ctrl+Shift+W：关闭所有打开文件Ctrl+Shift+V：粘贴并格式化Ctrl+D：选择单词，重复可增加选择下一个相同的单词Ctrl+L：选择行，重复可依次增加选择下一行Ctrl+Shift+L：选择多行Ctrl+Shift+Enter：在当前行前插入新行Ctrl+X：删除当前行Ctrl+M：跳转到对应括号Ctrl+U：软撤销，撤销光标位置Ctrl+J：合并为一行Ctrl+F：查找内容Ctrl+Shift+F：查找并替换Ctrl+H：替换Ctrl+R：查找methodCtrl+N：新建窗口Ctrl+K+B：开关侧栏Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身Ctrl+F2：设置/删除标记Ctrl+/：注释当前行Ctrl+Shift+/：当前位置插入注释Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的Ctrl+Shift+A：选择当前标签前后，修改标签用的F11：全屏Shift+F11：全屏免打扰模式，只编辑当前文件Alt+F3：选择所有相同的词Alt+.：闭合标签Alt+Shift+数字：分屏显示Alt+数字：切换打开第N个文件Shift+右键拖动：光标多不，用来更改或插入列内容鼠标的前进后退键可切换Tab文件按Ctrl，依次点击或选取，可需要编辑的多个位置按Ctrl+Shift+上下键，可替换行 ##选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。Ctrl+Shift+] 选中代码，按下快捷键，展开代码。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 ##编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写搜索类Ctrl+F 打开底部搜索框，查找关键字。Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，查找结果双击进入略高端，未研究。Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。Esc 退出光标多行选择，退出搜索框，命令框等。 ##显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown 向左切换当前窗口的标签页。Ctrl+PageUp 向右切换当前窗口的标签页。Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏Ctrl+K+B 开启/关闭侧边栏。 ##F11 全屏模式Shift+F11 免打扰模式注意:以上都是window下得快捷键，mac osc下会略有不同","tags":[{"name":"前端工具 sublime","slug":"前端工具-sublime","permalink":"http://myronliu.com/tags/前端工具-sublime/"}]},{"title":"javascript类型判断","date":"2015-11-09T09:26:00.000Z","path":"2015/11/09/javscript/javascript类型判断/","text":"判断String类型123function isString(value) &#123; return typeof value === 'string';&#125;; 判断Number类型123function(value) &#123; return typeof value === 'number';&#125;; 判断function123function isFunction(value) &#123; return typeof value === 'function';&#125;; 判断正则表达式类型123function isRegExp(value) &#123; return toString.call(value) === '[object RegExp]';&#125; 判断是否是对象123function isObject(value)&#123; return value !== null &amp;&amp; typeof value === 'object';&#125; 判断是否是Object的对象123function isBlankObject(value) &#123; return value !== null &amp;&amp; typeof value === 'object' &amp;&amp; ! getPrototypeOf(value);&#125;; 判断是否是数组123456function isArray(value)&#123; if (Object.prototype.toString.apply(arr) === '[object Array]') return true; else return false;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://myronliu.com/tags/javascript/"}]},{"title":"移动web开发准备工作","date":"2015-10-13T11:00:00.000Z","path":"2015/10/13/移动web/移动web开发准备工作/","text":"meta设置html5移动端页面窗口自适应设备宽度，防止用户缩放页面1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,minimal-ui\"&gt; 忽略将页面中的数字识别为电话号码1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; 忽略Android平台中对邮箱地址的识别1&lt;meta name=\"format-detection\" content=\"email=no\" /&gt; 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari，将网站添加到主屏幕快速启动方式，12&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt; 完整的html模板123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt;&lt;title&gt;标题&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt; css reset内容在移动端中需要对浏览器做一些特殊的处理，以保证样式的一致性。首先我们导入Normalize.css的代码，让后再加上移动端的特殊处理.123456789101112html&#123; font-family:Helvetica; font-size:10px;/*设置10px为1em*/ -webkit-tap-highlight-color: rgba(0,0,0,0);/*去掉触摸遮盖层*/ -webkit-user-modify:read-write-plaintext-only; -webkit-user-select: none;/*禁止用户选择文字*/ -webkit-overflow-scrolling: touch;/*滚动touch*/&#125;/*设置所有的盒子元素*/*&#123; box-sizing: border-box;&#125; css技巧消除闪屏1234/*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/-webkit-transform-style: preserve-3d;/*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/-webkit-backface-visibility: hidden; 清除浮动1234567891011.clearfix:before,.clearfix:after &#123; content: '\\0020'; display: block; overflow: hidden; visibility: hidden; width: 0; height: 0;&#125;.clearfix:after &#123; clear: both &#125;.clearfix &#123; *zoom: 1 &#125; ###部分android系统中元素被点击时产生的边框怎么去掉1234a,button,input,textarea&#123;-webkit-tap-highlight-color: rgba(0,0,0,0;)-webkit-user-modify:read-write-plaintext-only;&#125; 开启硬件加速123456.css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 如何阻止windows Phone的默认触摸事件1html&#123;-ms-touch-action: none;&#125;/* 禁止winphone默认触摸事件 */ js注意的地方 移动端上的点击事件会延迟300ms，可以使用touchstart代替（一般使用fastclick库）","tags":[]}]