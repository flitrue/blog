<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>myron blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="myron blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="myron blog">
<meta property="og:description" content="我的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="myron blog">
<meta name="twitter:description" content="我的技术博客">
  
    <link rel="alternative" href="/atom.xml" title="myron blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">myron</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/aa953788477" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/5837600189/info" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/javascript/" style="font-size: 10px;">javascript</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">myron</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">myron</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/aa953788477" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/5837600189/info" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-hexo-coding搭建自己的博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/24/hexo-coding搭建自己的博客/" class="article-date">
  	<time datetime="2016-03-24T14:39:24.000Z" itemprop="datePublished">2016-03-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/24/hexo-coding搭建自己的博客/">hexo+coding搭建自己的博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>毕业以来，尝试过用各种手段写博客，先是csdn的博客专栏谢了几篇文章之后，就懒了，只到去年，学习了markdown语法写博客，觉得非常好用，于是也开始用farbox写博客，最近接触一个hexo加上github的pages服务搭建博客，于是尝试下，犹豫github在国内的访问速度实在是不太好，我用coding代替.</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="1-NODE"><a href="#1-NODE" class="headerlink" title="1.NODE"></a>1.<a href="http://nodejs.cn/" target="_blank" rel="external">NODE</a></h3><p>犹豫hexo是基于node开发的，所以node环境是必须的</p>
<h3 id="2-git"><a href="#2-git" class="headerlink" title="2.git"></a>2.<a href="https://git-scm.com/download/" target="_blank" rel="external">git</a></h3><p>node的包管理都是需要使用git来down包的，我们提交文章和代码也需要用到git</p>
<h3 id="3-coding账号"><a href="#3-coding账号" class="headerlink" title="3.coding账号"></a>3.<a href="https://coding.net/" target="_blank" rel="external">coding</a>账号</h3><p>我们需要使用到 <em>coding</em> 的pages服务搭建博客，如果觉得coding的逼格不够的话，可以看下这篇文章<a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="external">HEXO+Github,搭建属于自己的博客</a></p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p><em>NODE</em> 和 <em>GIT</em> 都安装好了之后就可以下载安装 <em>hexo</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></p>
<p>国内的访问外网会有点慢，最好把npm仓库源设置为淘宝镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist</span><br></pre></td></tr></table></figure></p>
<p>安装完成之后新建一个文件夹，进入文件夹内执行 <em>init</em> 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure></p>
<p>init之后会看到文件下有了如下结构的文件<br><img src="http://blog.fens.me/wp-content/uploads/2014/05/hexo-folder.png" alt=""></p>
<h2 id="生成静态文件，本地启服务器调试"><a href="#生成静态文件，本地启服务器调试" class="headerlink" title="生成静态文件，本地启服务器调试"></a>生成静态文件，本地启服务器调试</h2><p>上面图片中的source目录就是存在我们文章地址的地方，文章用markdown语法编写，hexo还会自动解析，并进行分类和归档；执行以下命令可以生成静态文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p>
<p>本地启动服务器调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p>启动成功之后访问<a href="http://localhost:4000就可以看到你的主页啦，到此搭建工作就算基本完成了" target="_blank" rel="external">http://localhost:4000就可以看到你的主页啦，到此搭建工作就算基本完成了</a><br><img src="http://blog.fens.me/wp-content/uploads/2014/05/hexo-web.png" alt=""></p>
<h2 id="部署博客到coding上"><a href="#部署博客到coding上" class="headerlink" title="部署博客到coding上"></a>部署博客到coding上</h2><p>再coding上新建一个仓库，保证你的项目名称和用户名（个性后缀）一致，不然加载资源文件可能会有问题</p>
<p><img src="11-11.png" alt=""><br><img src="11-13.png" alt=""></p>
<p>更改 <em>_config.yml</em> 文件中的配置,一般在最后一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://git.coding.net/liuyy/liuyy.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>执行deploy命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>如果出现报错，先检查你的配置git地址是否正确，”:”号后面一定要跟一个空格,如果都没有问题则再安装一个包，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure></p>
<p>执行完成之后，去coding的项目目录项，开启pages服务,开启之后访问<a href="http://[user_name].coding.me,好了，大功告成。" target="_blank" rel="external">http://[user_name].coding.me,好了，大功告成。</a></p>
<h2 id="关于hexo的图片处理"><a href="#关于hexo的图片处理" class="headerlink" title="关于hexo的图片处理"></a>关于hexo的图片处理</h2><p>我从farbox中把原来的文章迁移过来，发现好多的图片都显示，再hexo中你要现先设置</p>
<p>post_asset_folder: true</p>
<p>设置完成之后，每一个markdown文件都有一个相同的名称的文件夹（迁移过来的文章是没有的需要自己创建）用来存储使用到的图片，再文章中，url只用写文件名称即可<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](11-11.png)</span><br></pre></td></tr></table></figure></p>
<h2 id="关于markdown编辑"><a href="#关于markdown编辑" class="headerlink" title="关于markdown编辑"></a>关于markdown编辑</h2><p>markdown的语法，大家看这篇文档就可以了，我就不多介绍了 <a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="external">Markdown语法说明</a><br>如果喜欢sublime编辑器的朋友我推荐使用下面两个markdown编辑的插件<br><em>MarkdownEditing</em> 它可以提供markdown文件很漂亮的语法高亮<br><em>Markdown Preview</em> markdown文件实时预览插件</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javscript/javascript面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/23/javscript/javascript面向对象编程/" class="article-date">
  	<time datetime="2016-03-23T11:19:00.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/23/javscript/javascript面向对象编程/">javascript面向对象编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>“面向对象编程”（Object Oriented Programming，缩写为OOP）是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<h2 id="对象的理解"><a href="#对象的理解" class="headerlink" title="对象的理解"></a>对象的理解</h2><p>那么，什么是对象呢？我们可以从两个层次理解：</p>
<p><em>（1）“对象”是单个实物的抽象。</em></p>
<p>一本书、一辆汽车、一个人都可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。当实物被抽象成“对象”，实物之间的关系就变成了“对象”之间的关系，从而就可以模拟现实情况，针对“对象”进行编程。</p>
<p><em>（2）“对象”是一个容器，封装了“属性”（property）和“方法”（method）。</em></p>
<p>所谓“属性”，就是对象的状态；所谓“方法”，就是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，“属性”记录具体是那一种动物，“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>“面向对象编程”的第一步，就是要生成“对象”。前面说过，“对象”是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后“对象”根据这个模板生成。</p>
<p>典型的面向对象语言（如：c#/java）,都有 <em>类</em> 这个概念用于构造对象， 对象就是类的实例，类就是对象的模板，但是，JavaScript语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p>
<blockquote>
<p>在ES6中也有了类的概念来构造对象</p>
</blockquote>
<p>构造函数是一个正常的函数，但是它的特征和用法与普通函数不一样。下面就是一个构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'myron'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，Person就是构造函数，通过this属性来封装自身的属性和方法，构造函数的特点有两个：</p>
<blockquote>
<ol>
<li>函数内部使用了this关键字，指向生成的对象;</li>
<li>必须用 <em>new</em> 命令调用函数生成对象；</li>
</ol>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myron = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>上面的代码就创建了一个新的对象，而new命令的执行过程是先创建一个空的对象，然后用这个对象去掉用构造函数完成是实例化操作，执行构造函数时会忽略到构造函数中的return语句,下面的代码来模拟new命令的执行过程;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"><span class="comment">/*构造函数，实例化参数*/</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = args.shift();</span><br><span class="line">    var context = Object.create(<span class="keyword">constructor</span>.prototype);//根据原型链创建新的对象</span><br><span class="line">    var result = <span class="keyword">constructor</span>.apply(context, args); //调用构造方法</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>JavaScript通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name + <span class="string">', '</span> + <span class="keyword">this</span>.age + <span class="string">' years old'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myron = <span class="keyword">new</span> Person(<span class="string">'myron'</span>, <span class="number">22</span>);</span><br><span class="line"><span class="keyword">var</span> ling = <span class="keyword">new</span> Person(<span class="string">'若绫'</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myron.introduce === ling.introduce);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中创建了两个实例, 但是它们的 <em>introduce</em> 方法却不一样，也就是，我们写在构造函数中的函数和属性在每次实例化得时候都会重新创建。对于一些公用的资源（函数/属性）来说，这既没有必要，又浪费系统资源，因为这些完全可以共享。</p>
<p>我们创建的每个函数都有一个 prototype(原型)属性,这个属性是一个对象,它的用途是<br>包含可以由特定类型的所有实例共享的属性和方法。逻辑上可以这么理解: prototype 通过 调用构造函数而创建的那个对象的原型对象 。使用原型的好处可以让所有对象实例共享它所 包含的属性和方法。也就是说,不必在构造函数中定义对象信息 ,而是可以直接将这些信息 添加到原型中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.introduce = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name + <span class="string">', '</span> + <span class="keyword">this</span>.age + <span class="string">' years old'</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myron = <span class="keyword">new</span> Person(<span class="string">'myron'</span>, <span class="number">22</span>);</span><br><span class="line"><span class="keyword">var</span> ling = <span class="keyword">new</span> Person(<span class="string">'若绫'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myron.introduce === ling.introduce);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>为了更进一步了解构造函数的声明方式和原型模式的声明方式 ,我们通过图示来了解一下:</p>
<p><img src="19-21-26.jpg" alt=""></p>
<p><img src="19-21-43.jpg" alt=""></p>
<p>在原型模式声明中,多了两个属性,这两个属性都是创建对象时自动生成的。<strong>proto</strong> 属性是实例指向原型对象的一个指针,它的作用就是指向构造函数的原型属性 constructor。 通过这两个属性,就可以访问到原型里的属性和方法了。</p>
<p>原型模式的执行流程:<br>1.先查找构造函数实例里的属性或方法,如果有,立刻返回;<br>2.如果构造函数实例里没有,则去它的原型对象里找,如果有,就返回;</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>javascript没有 <em>类</em> 的概念，自然也没有类的继承(ES6除外),我们只能通过一些独特的方法完成继承操作.</p>
<h3 id="属性拷贝"><a href="#属性拷贝" class="headerlink" title="属性拷贝"></a>属性拷贝</h3><p>这是最简单也最容易理解的继承方法，便利一个对象的所有属性，然后设置给另一个对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    a: <span class="string">'aa'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    b: <span class="string">'bb'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> a)&#123;</span><br><span class="line">    b[key] = a[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述继承方式只针对Object继承，只是对单个对象有用，又有一个对象需要继承a则需要重新遍历一次,所以我们函数再构造函数上动手脚吧</p>
<h3 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h3><p>再子类构造函数中用this对象调用父类构造函数方法，完成子类对父类的继承关系<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="string">'50kg'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.age === <span class="number">10</span> ? <span class="string">'完成继承啦'</span> : <span class="string">''</span>);</span><br></pre></td></tr></table></figure></p>
<p>但是这种方法，只能继承父类中构造函数定义的属性和方法，如果函数定义在原型中则无法继承;</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>之前就说每个函数都有prototype属性，用于共享属性和方法，但同同时它本身就是一个对象，也有自己的prototype,这样一来就形成一条原型继承链。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="string">'50kg'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name  = name; <span class="comment">//定义自己的属性</span></span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">//继承animal属性和方法</span></span><br><span class="line">Cat.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//新增一些原型属性和方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'喵~'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用原型继承可以完成做父类所有的方法和属性的继承，也可以定义一些子类特有的属性和方法.<br>推荐一下jQuery作者写的类工厂的实现 <a href="http://ejohn.org/blog/simple-javascript-inheritance/" target="_blank" rel="external">点这里</a></p>
<p>它通过 <em>Class.create</em> 方法创建类，需要继承则调用 <em>extend</em> 函数，另外在函数内部this._super指向父类的同名方法.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = Class.extend(&#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params">isDancing</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dancing = isDancing;</span><br><span class="line">  &#125;,</span><br><span class="line">  dance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dancing;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Ninja = Person.extend(&#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._super( <span class="literal">false</span> );</span><br><span class="line">  &#125;,</span><br><span class="line">  dance: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Call the inherited version of dance()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._super();</span><br><span class="line">  &#125;,</span><br><span class="line">  swingSword: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="literal">true</span>);</span><br><span class="line">p.dance(); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> Ninja();</span><br><span class="line">n.dance(); <span class="comment">// =&gt; false</span></span><br><span class="line">n.swingSword(); <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Should all be true</span></span><br><span class="line">p <span class="keyword">instanceof</span> Person &amp;&amp; p <span class="keyword">instanceof</span> Class &amp;&amp;</span><br><span class="line">n <span class="keyword">instanceof</span> Ninja &amp;&amp; n <span class="keyword">instanceof</span> Person &amp;&amp; n <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure></p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>Mixin是JavaScript中用的最普遍的模式，几乎所有流行类库都会有Mixin的实现。<br>Mixin是掺合，混合，糅合的意思，即可以就任意一个对象的全部或部分属性拷贝到另一个对象/类上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本的混合实现</span></span><br><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">    say : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.sayMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name  = name; <span class="comment">//定义自己的属性</span></span><br><span class="line">    <span class="keyword">this</span>.sayMsg = <span class="string">'喵~'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayMsg = <span class="string">'汪!汪!汪!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把mixin加入到两个类中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> mixin)&#123;</span><br><span class="line">    Cat.prototype[key] = mixin[key];</span><br><span class="line">    Dog.prototype[key] = mixin[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">'小黄'</span>);</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'旺财'</span>);</span><br><span class="line">cat.say();</span><br><span class="line">dog.say();</span><br></pre></td></tr></table></figure></p>
<p>很多时候，我们只需要使用到某个类中的一个或者两个方法，来避免重复定义函数，这个时候如果用继承来实现，那么代价就太大了，而且在多次继承之后，子类方法很可能写会不经意覆盖掉了祖类（父类的父类。。。）的方法导致对象有些操作不能正常完成。</p>
<p>因此我们只需要两级或者三级继承，将一些公用的功能或是函数都抽出来，作为一个个独立的object，需要使用到这些，就利用混合的方法加入到类中。这种方式，可以极大的提升代码的复用性。<br>我自己的实现：<a href="https://github.com/aa953788477/itools/blob/master/src/class/class.js" target="_blank" rel="external">可以继承和混合的类工厂</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javscript/javascript模块化编程(二)--commonjs,AMD,CMD" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/21/javscript/javascript模块化编程(二)--commonjs,AMD,CMD/" class="article-date">
  	<time datetime="2016-03-21T15:40:00.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/javscript/javascript模块化编程(二)--commonjs,AMD,CMD/">javascript模块化编程(二)--commonjs,AMD,CMD</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面的写法，再文件模块比较少的情况都不会有问题，但是再当模块比较多之后，window下还是会被挂载很多对象，而且当模块依赖过多的时候需要在’（）’，写很长的参数，于是乎，前端模块化，有了一些规范，让我们去定义模块。</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”，它采用异步加载模块的方法，使用require的方法先加载定义上数组中的依赖模块，全部完成后执行回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;module1&apos;], function(module1)&#123;</span><br><span class="line">    module1.doSomethings();//调用模块方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>采用异步加载，不会使浏览器卡死。也可以定义一个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(moduleId?, [modules]?, factory);</span><br></pre></td></tr></table></figure></p>
<p>其中</p>
<blockquote>
<p>moduleId 模块Id可以忽略，忽略的时候加载使用文件路径<br>modules 依赖模块,可以输模块id或是文件路径,没有可以忽略<br>factory 加载完依赖之后的回调方法，这里是模块定义的具体实现，利用return语句返回模块</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//注意依赖模块会返回对象，传入回调函数中</span><br><span class="line">define(&apos;render&apos;, [&apos;jQuery&apos;], function($)&#123;</span><br><span class="line">    //do somethings</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关于amd规范的实现：<a href="http://www.requirejs.cn/" target="_blank" rel="external">require.js</a></p>
<h2 id="cmd规范"><a href="#cmd规范" class="headerlink" title="cmd规范"></a>cmd规范</h2><p>CMD（Common Module Definition）公共模块定义规范，<br>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(factory)</span><br></pre></td></tr></table></figure></p>
<p>define 是一个全局函数，用来定义模块。<br>factory可以是一个JSON,字符串等等…<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;aa : <span class="string">"aa"</span>&#125;);</span><br><span class="line">define(<span class="string">'ddd'</span>);</span><br></pre></td></tr></table></figure></p>
<p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：<em>require</em>、<em>exports</em> 和 <em>module</em>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">'module1'</span>);</span><br><span class="line">    <span class="comment">// 正确写法</span></span><br><span class="line">    <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        foo: <span class="string">'bar'</span>,</span><br><span class="line">        doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>require 用于加载模块依赖；<br>exports 导出对象，等同于module.exports;<br>module 模块对象，用于使用module.exports导出对象;</p>
</blockquote>
<p>值得注意的是exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。<br>cmd规范实现：<a href="http://seajs.org/" target="_blank" rel="external">sea.js</a></p>
<h2 id="amd和cmd规范对比；"><a href="#amd和cmd规范对比；" class="headerlink" title="amd和cmd规范对比；"></a>amd和cmd规范对比；</h2><p>相较于amd而言cmd的规范的优势很明显</p>
<blockquote>
<p>1.按需加载, amd将依赖前置到模块定义时，也就是有些模块尚未使用到就加载了，暂用内存，不合理.<br>2.CMD推崇依赖就近，AMD推崇依赖前置。当依赖模块过多时，回调函数如会有很长一条参数对象.</p>
</blockquote>
<h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><p>CommonJs 是服务器端模块的规范，Node.js采用了这个规范。<br>根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var test=&quot;a&quot;;//私有变量</span><br><span class="line">var $ = require(&apos;jQuery&apos;);//拉取文件依赖</span><br><span class="line">exports.aa = function ()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">exports.bb =  function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//也可以这么写</span><br><span class="line">module.exports = &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD  CMD 解决方案。<br>现在利用一些前端打包工具，我们也可以是使用标准的额common.js规范编码了，<a href="http://browserify.org/" target="_blank" rel="external">browserify</a>,<a href="http://webpack.github.io/" target="_blank" rel="external">webpack</a>;</p>
<h2 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h2><p>我们编写一个模块，并不知道它要在哪种规范下使用，于是，需要一种编写方式能同事兼容Amd和CommonJs模块化实现，这就是umd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(function (window, factory) &#123;</span><br><span class="line">    if (typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">        module.exports = factory();</span><br><span class="line">    &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        window.module1 = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this, function () &#123;</span><br><span class="line">    //module ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。<br>在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。<br>如果都不存在模块化实现那么就放在window对象下。</p>
<h2 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h2><p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。<br>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>
<h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export var name1 = &apos;Michael&apos;;</span><br><span class="line">export var name2 = &apos;Jackson&apos;;</span><br><span class="line">export var name3 = 1958;</span><br></pre></td></tr></table></figure></p>
<h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">import ajax from &apos;../ajax.js&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// export-default.js</span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&apos;foo&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是一个模块文件export-default.js，它的默认输出是一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// import-default.js</span><br><span class="line">import customName from &apos;./export-default&apos;;</span><br><span class="line">customName(); // &apos;foo&apos;</span><br></pre></td></tr></table></figure></p>
<p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。<br>Es6中已经提供了比较完善的模块化方案，但是目前兼容不太好，只能通过babel转码成es5代码再通过webpack打包.<br>ES6模块化这部门讲的比较粗糙，如果感兴趣可以看下阮一峰大大的教程<br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript6入门-Module</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javscript/javascript模块化编程(一)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/21/javscript/javascript模块化编程(一)/" class="article-date">
  	<time datetime="2016-03-21T15:30:00.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/javscript/javascript模块化编程(一)/">javascript模块化编程(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着web开发逐渐演变成web application之后，尤其是在web2.0依赖页面上的javascript脚本逐渐变多，嵌入网页的JavaiScript代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者需要分模块，来管理前端代码开发。</p>
<h2 id="原始写法"><a href="#原始写法" class="headerlink" title="原始写法"></a>原始写法</h2><p>模块就是实现特定功能的一组方法。只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = <span class="string">''</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do somethings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mehtod2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do somthings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面吧state和方法放在一起组成一个模块，要使用的是否，直接调用方法即可。但是这种做法缺点也很明显，吧，变量和方法都放在了全局变量里，造成了全局污染，一但模块数量变多，后面相同名称方法或是变量就会覆盖之前的，产生一些奇怪的bug.<br>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = &#123;</span><br><span class="line">    state : <span class="string">''</span>,</span><br><span class="line">    method1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do somethings</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mehtod2 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种写法将方法和变量都封装到了module1里，调用的时候直接 <strong>对象.方法名</strong> 就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.mehtod1();</span><br></pre></td></tr></table></figure></p>
<p>但是，这样的写法会暴露所有模块成员，内部变量可以被外部改写。比如，外部的代码可以直接修改state的值。</p>
<h2 id="用面向对象构造函数，封装私有对象"><a href="#用面向对象构造函数，封装私有对象" class="headerlink" title="用面向对象构造函数，封装私有对象"></a>用面向对象构造函数，封装私有对象</h2><p>利用构造函数的特性，封装私有对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ModuleClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hello = <span class="string">'hello world'</span>;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(hello);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> ModuleClass();</span><br><span class="line"><span class="built_in">module</span>.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>这样私有变量在外部就不会被访问到，这种把函数直接写在写在构造函数内部的做法，每次实例化的时候都会创建这个函数，非常耗费内存。<br>利用prototype(原型)改写上面的程序如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ModuleClass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello = <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line">ModuleClass.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改写之后，将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写。</p>
<h2 id="利用立即执行函数写法写模块"><a href="#利用立即执行函数写法写模块" class="headerlink" title="利用立即执行函数写法写模块"></a>利用立即执行函数写法写模块</h2><p>使用”立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hello = <span class="string">'hello world'</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sayHello : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(hello);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>这样一来，外部就无法访问到私有的hello变量了。<br>更多的时候我们模块需要一来另一些模块或者全局变量，返回的时候挂载再全局变量上<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, $</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hello = <span class="string">'hello world'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里也可以对引入对象进行扩展</span></span><br><span class="line">    $.fn.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.module1 = &#123;</span><br><span class="line">        sayHello : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(hello);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure></p>
<p>如果这个模块需要让外部调用哪些方法，只用挂载到module1上就可以了,同时，立即执行函数内部也可以对引入对象（例如jQuery，做扩展操作。以保证内部的方法和变量都是独立的，不会影响到外面</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-css/css布局-BFC和IFC" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/04/css/css布局-BFC和IFC/" class="article-date">
  	<time datetime="2016-03-04T04:29:00.000Z" itemprop="datePublished">2016-03-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/04/css/css布局-BFC和IFC/">css布局-BFC和IFC</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Formatting Contexts是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC(Block Formatting Contexts)直译为”块级格式化上下文”。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素,反之也是如此。</p>
<h3 id="BFC形成"><a href="#BFC形成" class="headerlink" title="BFC形成"></a>BFC形成</h3><blockquote>
<ul>
<li>float 的值不为 none</li>
<li>position 的值不为 static 或 relative</li>
<li>display属性为inline-boxs、table-cells、table-captions的不是块盒的块容器(除非这个值已经被传播到视口),</li>
<li>overflow不为visible的块盒才会为它的内容创建新的BFC。</li>
<li>body元素</li>
</ul>
</blockquote>
<h3 id="BFC渲染规则"><a href="#BFC渲染规则" class="headerlink" title="BFC渲染规则"></a>BFC渲染规则</h3><blockquote>
<ol>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠，常用来清除浮动和布局。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
</blockquote>
<h2 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h2><p>IFC(Inline Formatting Contexts)直译为”内联格式化上下文”，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)</p>
<h3 id="IFC渲染规则"><a href="#IFC渲染规则" class="headerlink" title="IFC渲染规则"></a>IFC渲染规则</h3><blockquote>
<ol>
<li>框会从包含块的顶部开始，一个接一个地水平摆放。</li>
<li>摆放这些框的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。在垂直方向上，这些框可能会以不同形式来对齐：它们可能会把底部或顶部对齐，也可能把其内部的文本基线对齐。能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框。水平的margin、padding、border有效，垂直无效。不能指定宽高。</li>
<li>行框的宽度是由包含块和存在的浮动来决定。</li>
</ol>
</blockquote>
<h3 id="IFC-‘line-height’-与-‘vertical-align’-属性"><a href="#IFC-‘line-height’-与-‘vertical-align’-属性" class="headerlink" title="IFC  ‘line-height’ 与 ‘vertical-align’ 属性"></a>IFC  ‘line-height’ 与 ‘vertical-align’ 属性</h3><blockquote>
<ol>
<li>计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其 ‘line-height’。</li>
<li><p>行内级元素根据其 ‘vertical-align’ 属性垂直对齐。在这些框使用 ‘top’ 或 ‘bottom’ 对齐的情况下，user-agent必须以最小化行框的高为目标对齐这些框。若这些框够高，则存在多个解而 CSS 2.1 不定义行框基线的位置。</p>
</li>
<li><p>行框的高是最顶端框的顶边到最底端框的底边的距离。</p>
</li>
</ol>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-css/css布局-盒模型，定位和浮动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/04/css/css布局-盒模型，定位和浮动/" class="article-date">
  	<time datetime="2016-03-04T04:27:00.000Z" itemprop="datePublished">2016-03-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/04/css/css布局-盒模型，定位和浮动/">css布局-盒模型，定位和浮动</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>简单来说，网页中的额每一个元素都是一个盒子，而整个网页就是有大大小小的盒子组装起来的。既然是盒子那么它就有：内容（content）、填充（padding）、边框（border）、边界（margin）这些属性，而每个属性又有上下左右四个方向，像下面这张图这样<br><img src="13-34-30.jpg" alt=""></p>
<h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>每一个元素都是一个盒子，display属性就决定了他们属于那种盒子；目前大致分为以下几种</p>
<h3 id="块级元素（block）"><a href="#块级元素（block）" class="headerlink" title="块级元素（block）"></a>块级元素（block）</h3><p>一般是其他元素的容器，可容纳内联元素和其他块状元素，块状元素排斥其他元素与其位于同一行，宽度(width)高度(height)起作用。常见块状元素为div和p。</p>
<h3 id="内联元素-inline"><a href="#内联元素-inline" class="headerlink" title="内联元素(inline)"></a>内联元素(inline)</h3><p>内联元素只能容纳文本或者其他内联元素，它允许其他内联元素与其位于同一行，但宽度(width)高度(height)不起作用。常见内联元素为“a”。</p>
<h3 id="内联块级元素-inline-block"><a href="#内联块级元素-inline-block" class="headerlink" title="内联块级元素(inline block)"></a>内联块级元素(inline block)</h3><p>同时拥有块级元素和内联元素的特性</p>
<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>display决定了盒子种类，position就确定了盒子的位置，</p>
<h3 id="（标准文档流）static"><a href="#（标准文档流）static" class="headerlink" title="（标准文档流）static"></a>（标准文档流）static</h3><p>常规元素默认值都是static，指按照文档至上而下的标准文档流</p>
<h3 id="（绝对定位）absolute"><a href="#（绝对定位）absolute" class="headerlink" title="（绝对定位）absolute"></a>（绝对定位）absolute</h3><p>绝对定位，他默认参照已经定位(position值不为static)的元素父级元素，配合top、right、bottom、left进行定位。<br>脱离标准文档流，也就是他的位置不会影响到其他的元素，也不会参与到父元素高度计算上，但是会受到富元素overflow:hidden的影响</p>
<h3 id="（绝对定位）fixed"><a href="#（绝对定位）fixed" class="headerlink" title="（绝对定位）fixed"></a>（绝对定位）fixed</h3><p>参照window配合top、right、bottom、left进行定位。<br>脱离标准文档流，不会受到父元素overflow:hidden影响;</p>
<h3 id="（相对定位）relative"><a href="#（相对定位）relative" class="headerlink" title="（相对定位）relative"></a>（相对定位）relative</h3><p>相对定位，他是默认参照父级的原始点为原始点，配合top、right、bottom、left进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位。</p>
<h2 id="浮动（float）"><a href="#浮动（float）" class="headerlink" title="浮动（float）"></a>浮动（float）</h2><p>首先要知道，div是块级元素，在页面中独占一行，自上而下排列，那么如何让块级元素在一行中显示呢，这里就用到float;<br>float:left/right可以让块级元素在一行中从左至右或者从右至左排列，但是，需要主要的是，当元素设置了float:left/right时，会影响到后面的元素所以需要及时的清除浮动，而且会造成父级元素高度塌陷。<br>常用的清除浮动代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.clear &#123; clear: both; &#125;/*清除浮动*/</span><br><span class="line">/*清除浮动并防止父级元素高度塌陷*/</span><br><span class="line">.clearfix:before, .clearfix:after &#123; </span><br><span class="line">    content: '\0020'; </span><br><span class="line">    display: block; </span><br><span class="line">    overflow: hidden; </span><br><span class="line">    visibility: hidden; </span><br><span class="line">    width: 0; height: 0; </span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123; clear: both &#125;</span><br><span class="line">.clearfix &#123; *zoom: 1 &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-javscript/javascript类工厂构建" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/06/javscript/javascript类工厂构建/" class="article-date">
  	<time datetime="2015-12-06T14:43:00.000Z" itemprop="datePublished">2015-12-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/06/javscript/javascript类工厂构建/">javascript类工厂构建</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下面的代码基于javascript原型继承设计，轻量，好用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> initializing = <span class="literal">false</span>,</span><br><span class="line">	fnTest = <span class="regexp">/xyz/</span>.test(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		xyz;</span><br><span class="line">	&#125;) ? <span class="regexp">/\b_super\b/</span> : <span class="regexp">/.*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Class.extend = <span class="function"><span class="keyword">function</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> _super = <span class="keyword">this</span>.prototype;</span><br><span class="line">	initializing = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">var</span> prototype = <span class="keyword">new</span> <span class="keyword">this</span>();</span><br><span class="line">	initializing = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> prop) &#123;</span><br><span class="line">		prototype[name] = <span class="keyword">typeof</span> prop[name] == <span class="string">"function"</span> &amp;&amp;</span><br><span class="line">			<span class="keyword">typeof</span> _super[name] == <span class="string">"function"</span> &amp;&amp; fnTest.test(prop[name]) ?</span><br><span class="line">			(<span class="function"><span class="keyword">function</span>(<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">					<span class="keyword">var</span> tmp = <span class="keyword">this</span>._super;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">this</span>._super = _super[name];</span><br><span class="line"></span><br><span class="line">					<span class="keyword">var</span> ret = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">					<span class="keyword">this</span>._super = tmp;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">return</span> ret;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;)(name, prop[name]) :</span><br><span class="line">			prop[name];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Class</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!initializing &amp;&amp; <span class="keyword">this</span>.init)</span><br><span class="line">			<span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Class.prototype = prototype;</span><br><span class="line">	Class.prototype.constructor = Class;</span><br><span class="line">	Class.extend = <span class="built_in">arguments</span>.callee;</span><br><span class="line">	<span class="keyword">return</span> Class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = Class.extend(&#123;</span><br><span class="line">    init :  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'the class'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//B继承A</span></span><br><span class="line"><span class="keyword">var</span> B = A.extend(&#123;</span><br><span class="line">    init : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._super();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-移动web/前端seo优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/24/移动web/前端seo优化/" class="article-date">
  	<time datetime="2015-11-24T13:44:00.000Z" itemprop="datePublished">2015-11-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/24/移动web/前端seo优化/">前端seo优化</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">核心心法：让小蜘蛛最快找到有用信息</span><br><span class="line">1. &lt;p&gt;&lt;br/&gt;&lt;/p&gt;很赞的写法 &lt;br/&gt;写在p内部</span><br><span class="line">2.外链 要加上 rel=“nofollow” 避免搜索引擎爬网爬跑掉其他网页去了</span><br><span class="line">3.&lt;a&gt;标签加title描述</span><br><span class="line">4.&lt;img&gt;标签加alt描述</span><br><span class="line">5.标签中的内容就是内容，不要加的代码，&amp;nbsp尽量设置padding/margin/缩进来实现效果</span><br><span class="line">a. &lt;title&gt; 关键词放前面；不重复；每个title不同；</span><br><span class="line">b. &lt;meta keywords&gt; 列出关键词即可，不需太多；</span><br><span class="line">c. &lt;meta description&gt; 高度概括网页内容，不需太多，每个页面不同；</span><br><span class="line">d. 语义化代码：</span><br><span class="line">aa. H1-H6 用于标题；</span><br><span class="line">bb. UL无序列表；</span><br><span class="line">cc. OL有序列表；</span><br><span class="line">dd. DL定义数据列表</span><br><span class="line">ee. em,strong 强调</span><br><span class="line">e. 优化：</span><br><span class="line">aa. &lt;a&gt; title/rel/</span><br><span class="line">bb. &lt;h1&gt; 正文标题一定用H1，副标题H2；</span><br><span class="line">cc. &lt;p&gt; &lt;br&gt;是文本内的换行；</span><br><span class="line">dd. &lt;caption&gt;表格标题；</span><br><span class="line">ee. &lt;img&gt; 加alt说明；</span><br><span class="line">ff. &lt;strong&gt;（高度重视） &lt;em&gt; （仅次于strong）&amp; &lt;b&gt;（不推荐） &lt;i&gt;</span><br><span class="line">gg. 重要HTML放在最前面；</span><br><span class="line">hh. 重要内容不用JS输出；</span><br><span class="line">ii. 少使用iframe框架；</span><br><span class="line">JJ. 谨慎使用display:none（使用z-index）;</span><br><span class="line">kk. 精简代码；</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-移动web/Yahoo军规" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/24/移动web/Yahoo军规/" class="article-date">
  	<time datetime="2015-11-24T13:43:00.000Z" itemprop="datePublished">2015-11-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/24/移动web/Yahoo军规/">前端代码规范(YaHoo军规)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.尽可能减少HTTP请求数（请求耗时）<br>2.使用CDN（内容分发网络）<br>3.添加Expire/Cache-Control头（缓存设置）<br>4.启用Gzip压缩（压缩css和js代码，混淆js代码）<br>5.把css放在页面最上面（方便加载渲染）<br>6.把script放在页面最下面（防止script代码影响页面展示）<br>7.避免在css中使用Expression<br>8.把JavaScript和css放在外部分文件中（js和css文件浏览器是自动缓存的不会重复加载）<br>9.减少DNS查询<br>10.避免重定向</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端工具/sublime常用的插件介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/11/16/前端工具/sublime常用的插件介绍/" class="article-date">
  	<time datetime="2015-11-16T00:06:00.000Z" itemprop="datePublished">2015-11-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/16/前端工具/sublime常用的插件介绍/">sublime常用的插件介绍</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h2><p>包管理器，安装这个插件之后可以管理sublime的所有的扩展包的安装和卸载<br>安装方法如下，打开console窗口（CTRL+`/views&gt;show console）将下面这段代码copy进去敲enter即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure></p>
<p>接下来得插件安装，<br>1.打开命令面板ctrl+shift+p<br>2.输入ip,enter<br>3.输入插件名称敲击enter</p>
<h2 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a><a href="http://docs.emmet.io" target="_blank" rel="external">Emmet</a></h2><p>前身事大名鼎鼎的zen coding，仅仅需要一行代码就能快速生成html代码。简单的语法既可以生成负责html css代码(点击标题，可以学习emmet语法)，</p>
<h2 id="SideBar-Enhancements"><a href="#SideBar-Enhancements" class="headerlink" title="SideBar Enhancements"></a>SideBar Enhancements</h2><p>这个插件改进了侧边栏，增加了许多功能：将文件移入回收站，在浏览器中浏览，将文件复制到剪切板。<br><img src="15-31-34.jpg" alt=""></p>
<h2 id="AutoFileName"><a href="#AutoFileName" class="headerlink" title="AutoFileName"></a>AutoFileName</h2><p>文件名称自动补全插件<br><img src="15-32-45.jpg" alt=""></p>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p>css3的语言环境，也会对一些css3的属性惊醒提示</p>
<h2 id="DocBlockr"><a href="#DocBlockr" class="headerlink" title="DocBlockr"></a>DocBlockr</h2><p>文本注释插件，再js方法上敲击/**+ enter即可变成下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * [ description]</span><br><span class="line"> * @param  &#123;[type]&#125; item [description]</span><br><span class="line"> * @return &#123;[type]&#125;      [description]</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<h2 id="JsFormat"><a href="#JsFormat" class="headerlink" title="JsFormat"></a>JsFormat</h2><p>javascript格式化插件，安装之后选择文本ctrl+alt+f可以格式化指定文本</p>
<h2 id="SublimeCodeIntel"><a href="#SublimeCodeIntel" class="headerlink" title="SublimeCodeIntel"></a>SublimeCodeIntel</h2><p>多种语言提示，代码自动补齐，快速跳转到变量定义，在状态栏显示函数快捷信息等<br>它支持的语言有：PHP, Python, RHTML, JavaScript, Smarty, Mason, Node.js, XBL, Tcl, HTML, HTML5, TemplateToolkit, XUL, Django, Perl, Ruby, Python3.</p>
<h2 id="SublimeLinter"><a href="#SublimeLinter" class="headerlink" title="SublimeLinter"></a>SublimeLinter</h2><p>代码检查插件，可以提示你的编码错误，但是需要安装子包，例如<br>1.javascript语法检查 SublimeLinter-jshint这个包是必须得；<br>2.css语法检查 sublimeLinter-csslint<br><img src="15-43-40.jpg" alt=""></p>
<h2 id="SublimeLinter-csslint"><a href="#SublimeLinter-csslint" class="headerlink" title="SublimeLinter-csslint"></a>SublimeLinter-csslint</h2><p>配置sublimelinter，的css语法检查插件</p>
<h2 id="SublimeLinter-jshint"><a href="#SublimeLinter-jshint" class="headerlink" title="SublimeLinter-jshint"></a>SublimeLinter-jshint</h2><p>配置sublimelinter，的js语法检查插件</p>
<h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>HTML/XML 标签缩进、补全和校验；</p>
<h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h2><p>打开控制台插件，安装后配置上下面的快捷键即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;keys&quot;: [&quot;command+shift+m&quot;], &quot;command&quot;: &quot;open_terminal&quot; &#125;,`</span><br></pre></td></tr></table></figure></p>
<h2 id="TrailingSpaces"><a href="#TrailingSpaces" class="headerlink" title="TrailingSpaces"></a>TrailingSpaces</h2><p>多余空格标记插件，会标记每行多余的空格，加入下边的快捷键配置即可一次删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;keys&quot;: [&quot;command+shift+t&quot;], &quot;command&quot;: &quot;delete_trailing_spaces&quot; &#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="主题包"><a href="#主题包" class="headerlink" title="主题包"></a>主题包</h2><p>sublime本身的外表就已经很好看了，如果大家对颜值有特殊要求的，可以<a href="http://www.techug.com/9-best-sublime-text-themes" target="_blank" rel="external">点击这里</a></p>
<h2 id="各种framework包"><a href="#各种framework包" class="headerlink" title="各种framework包"></a>各种framework包</h2><ul>
<li>jQuery jquery的代码补全包；</li>
<li>Angular angular的代码补全及常用指令提示；</li>
<li>less   less的环境高亮</li>
<li>saas    sass的语法环境高亮，以及代码提示<br>….</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 myron
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>