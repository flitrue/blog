<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>javascript模块化编程(二)--commonjs,AMD,CMD | 精神病聚集地</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前面的写法，再文件模块比较少的情况都不会有问题，但是再当模块比较多之后，window下还是会被挂载很多对象，而且当模块依赖过多的时候需要在’（）’，写很长的参数，于是乎，前端模块化，有了一些规范，让我们去定义模块。">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript模块化编程(二)--commonjs,AMD,CMD">
<meta property="og:url" content="http://myronliu.com/2016/03/21/javscript/javascript模块化编程(二)--commonjs,AMD,CMD/index.html">
<meta property="og:site_name" content="精神病聚集地">
<meta property="og:description" content="前面的写法，再文件模块比较少的情况都不会有问题，但是再当模块比较多之后，window下还是会被挂载很多对象，而且当模块依赖过多的时候需要在’（）’，写很长的参数，于是乎，前端模块化，有了一些规范，让我们去定义模块。">
<meta property="og:updated_time" content="2016-04-02T10:15:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript模块化编程(二)--commonjs,AMD,CMD">
<meta name="twitter:description" content="前面的写法，再文件模块比较少的情况都不会有问题，但是再当模块比较多之后，window下还是会被挂载很多对象，而且当模块依赖过多的时候需要在’（）’，写很长的参数，于是乎，前端模块化，有了一些规范，让我们去定义模块。">
  
    <link rel="alternate" href="/atom.xml" title="精神病聚集地" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/uicon.jpg">
    <h2 class="author">myron</h2>
    <h3 class="description">一只疯了的前端🐶</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>48</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags/vue"><div><strong>25</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/vue" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-javscript/javascript模块化编程(二)--commonjs,AMD,CMD" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/javscript/javascript模块化编程(二)--commonjs,AMD,CMD/" class="article-date">
  <time class="post-time" datetime="2016-03-21T15:40:00.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      javascript模块化编程(二)--commonjs,AMD,CMD
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面的写法，再文件模块比较少的情况都不会有问题，但是再当模块比较多之后，window下还是会被挂载很多对象，而且当模块依赖过多的时候需要在’（）’，写很长的参数，于是乎，前端模块化，有了一些规范，让我们去定义模块。<br><a id="more"></a></p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”，它采用异步加载模块的方法，使用require的方法先加载定义上数组中的依赖模块，全部完成后执行回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require([&apos;module1&apos;], function(module1)&#123;</div><div class="line">    module1.doSomethings();//调用模块方法</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>采用异步加载，不会使浏览器卡死。也可以定义一个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(moduleId?, [modules]?, factory);</div></pre></td></tr></table></figure></p>
<p>其中</p>
<blockquote>
<p>moduleId 模块Id可以忽略，忽略的时候加载使用文件路径<br>modules 依赖模块,可以输模块id或是文件路径,没有可以忽略<br>factory 加载完依赖之后的回调方法，这里是模块定义的具体实现，利用return语句返回模块</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//注意依赖模块会返回对象，传入回调函数中</div><div class="line">define(&apos;render&apos;, [&apos;jQuery&apos;], function($)&#123;</div><div class="line">    //do somethings</div><div class="line">    return &#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>关于amd规范的实现：<a href="http://www.requirejs.cn/" target="_blank" rel="external">require.js</a></p>
<h2 id="cmd规范"><a href="#cmd规范" class="headerlink" title="cmd规范"></a>cmd规范</h2><p>CMD（Common Module Definition）公共模块定义规范，<br>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define(factory)</div></pre></td></tr></table></figure></p>
<p>define 是一个全局函数，用来定义模块。<br>factory可以是一个JSON,字符串等等…<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">define(&#123;<span class="attr">aa</span> : <span class="string">"aa"</span>&#125;);</div><div class="line">define(<span class="string">'ddd'</span>);</div></pre></td></tr></table></figure></p>
<p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：<em>require</em>、<em>exports</em> 和 <em>module</em>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">'module1'</span>);</div><div class="line">    <span class="comment">// 正确写法</span></div><div class="line">    <span class="built_in">module</span>.exports = &#123;</div><div class="line">        <span class="attr">foo</span>: <span class="string">'bar'</span>,</div><div class="line">        <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>require 用于加载模块依赖；<br>exports 导出对象，等同于module.exports;<br>module 模块对象，用于使用module.exports导出对象;</p>
</blockquote>
<p>值得注意的是exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。<br>cmd规范实现：<a href="http://seajs.org/" target="_blank" rel="external">sea.js</a></p>
<h2 id="amd和cmd规范对比；"><a href="#amd和cmd规范对比；" class="headerlink" title="amd和cmd规范对比；"></a>amd和cmd规范对比；</h2><p>相较于amd而言cmd的规范的优势很明显</p>
<blockquote>
<p>1.按需加载, amd将依赖前置到模块定义时，也就是有些模块尚未使用到就加载了，暂用内存，不合理.<br>2.CMD推崇依赖就近，AMD推崇依赖前置。当依赖模块过多时，回调函数如会有很长一条参数对象.</p>
</blockquote>
<h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><p>CommonJs 是服务器端模块的规范，Node.js采用了这个规范。<br>根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var test=&quot;a&quot;;//私有变量</div><div class="line">var $ = require(&apos;jQuery&apos;);//拉取文件依赖</div><div class="line">exports.aa = function ()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">exports.bb =  function()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">//也可以这么写</div><div class="line">module.exports = &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD  CMD 解决方案。<br>现在利用一些前端打包工具，我们也可以是使用标准的额common.js规范编码了，<a href="http://browserify.org/" target="_blank" rel="external">browserify</a>,<a href="http://webpack.github.io/" target="_blank" rel="external">webpack</a>;</p>
<h2 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h2><p>我们编写一个模块，并不知道它要在哪种规范下使用，于是，需要一种编写方式能同事兼容Amd和CommonJs模块化实现，这就是umd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(function (window, factory) &#123;</div><div class="line">    if (typeof exports === &apos;object&apos;) &#123;</div><div class="line">        module.exports = factory();</div><div class="line">    &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</div><div class="line">        define(factory);</div><div class="line">    &#125; else &#123;</div><div class="line">        window.module1 = factory();</div><div class="line">    &#125;</div><div class="line">&#125;)(this, function () &#123;</div><div class="line">    //module ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。<br>在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。<br>如果都不存在模块化实现那么就放在window对象下。</p>
<h2 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h2><p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。<br>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6模块</span></div><div class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</div></pre></td></tr></table></figure></p>
<p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>
<h3 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h3><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export var name1 = &apos;Michael&apos;;</div><div class="line">export var name2 = &apos;Jackson&apos;;</div><div class="line">export var name3 = 1958;</div></pre></td></tr></table></figure></p>
<h3 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">import ajax from &apos;../ajax.js&apos;</div></pre></td></tr></table></figure></p>
<h3 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// export-default.js</div><div class="line">export default function () &#123;</div><div class="line">  console.log(&apos;foo&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码是一个模块文件export-default.js，它的默认输出是一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// import-default.js</div><div class="line">import customName from &apos;./export-default&apos;;</div><div class="line">customName(); // &apos;foo&apos;</div></pre></td></tr></table></figure></p>
<p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。<br>Es6中已经提供了比较完善的模块化方案，但是目前兼容不太好，只能通过babel转码成es5代码再通过webpack打包.<br>ES6模块化这部门讲的比较粗糙，如果感兴趣可以看下阮一峰大大的教程<br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="external">ECMAScript6入门-Module</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://myronliu.com/2016/03/21/javscript/javascript模块化编程(二)--commonjs,AMD,CMD/" data-id="cj7fx25pv0014oe77lzj1u876" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/03/23/javscript/javascript面向对象编程/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          javascript面向对象编程
        
      </div>
    </a>
  
  
    <a href="/2016/03/21/javscript/javascript模块化编程(一)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">javascript模块化编程(一)</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">精神病聚集地</h1>
    <h2 class="blog-subtitle">死宅万岁，bilibili ( ゜- ゜)つロ 乾杯~</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/vue" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="/images/uicon.jpg">
    <h2 class="author">myron</h2>
    <h3 class="description">一只疯了的前端🐶</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>48</strong><br>文章</div></a>
      <a href="/categories"><div><strong>0</strong><br>分类</div></a>
      <a href="/tags/vue"><div><strong>25</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/myronliu347" target="_blank" title="github">
          github
        </a>
      
        <a class="hvr-bounce-in" href="mailto:myronliu347@gmail.com" target="_blank" title="email">
          email
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.shanamaid.top/" target="_blank" title="ShanaMaid">
          ShanaMaid
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2016 - 2017 myron<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags/vue" title="" class="menuItem">标签</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>